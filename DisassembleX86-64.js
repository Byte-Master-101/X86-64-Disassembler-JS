/*-------------------------------------------------------------------------------------------------------------------------
Binary byte code array.
-------------------------------------------------------------------------------------------------------------------------*/

var BinCode = new Array();

/*-------------------------------------------------------------------------------------------------------------------------
When Bit Mode is 2 the disassembler will default to decoding 64 bit binary code possible settings are 0=16 bit, 1=32 bit, 2=64 bit.
-------------------------------------------------------------------------------------------------------------------------*/

var BitMode = 2;

/*-------------------------------------------------------------------------------------------------------------------------
CodePos32 is the actual position in the Binary byte code array.
However It is limited to an Uint32 number because JavaScript does not use 64 bit indexes.
-------------------------------------------------------------------------------------------------------------------------*/

var CodePos32 = 0x00000000;

/*-------------------------------------------------------------------------------------------------------------------------
The simulated 64 bit address binary location uses two 32 bit integers.
This allows you to set an 64 bit address base location using the function SetBasePosition(Address64).
In which all binary instructions in the Binary byte code array disassemble as if they are located in that address.
While the CodePos32 moves though the array of hex values normally for your X86 instructions.
-------------------------------------------------------------------------------------------------------------------------*/

var Pos64 = 0x00000000, Pos32 = 0x00000000;

/*-------------------------------------------------------------------------------------------------------------------------
The InstructionHex String stores the Bytes of decoded instructions. It is shown to the left side of the disassembled instruction.
-------------------------------------------------------------------------------------------------------------------------*/

var InstructionHex = "";

/*-------------------------------------------------------------------------------------------------------------------------
The InstructionPos String stores the start position of a decoded binary instruction in memory.
-------------------------------------------------------------------------------------------------------------------------*/

var InstructionPos = "";

/*-------------------------------------------------------------------------------------------------------------------------
Decoding display options.
-------------------------------------------------------------------------------------------------------------------------*/

var ShowInstructionHex = true; //setting to show the hex code of the instruction beside the decoded instruction output.
var ShowInstructionPos = true; //setting to show the instruction address position.

/*-------------------------------------------------------------------------------------------------------------------------
The Opcode, and Opcode map.
---------------------------------------------------------------------------------------------------------------------------
The first byte that is read is the selected instruction code however some codes are used as Adjustment codes.
Used by the function ^DecodePrefixAdjustments()^. The first byte opcodes are 0 to 255, but some codes are used as Adjustments.
---------------------------------------------------------------------------------------------------------------------------
Bellow XX is the opcode combined with the adjustment codes and how opcode works in binary.
---------------------------------------------------------------------------------------------------------------------------
00,00000000 = 0, lower 8 bit opcode at max 00,11111111 = 255. (First byte opcodes XX) Opcodes values 0 to 255.
01,00000000 = 256, lower 8 bit opcode at max 01,11111111 = 511. (Two byte opcode 0F XX) Opcodes values 256 to 511.
10,00000000 = 512, lower 8 bit opcode at max 10,11111111 = 767. (Three byte opcode 0F 38 XX) Opcodes values 512 to 767
11,00000000 = 768, lower 8 bit opcode at max 11,11111111 = 1023. (Three byte opcode 0F 3A XX) Opcodes values 768 to 1023.
---------------------------------------------------------------------------------------------------------------------------
The lower 8 bits is the selectable opcode 0 to 255 plus one from 255 is 1,00000000 = 256 thus 256 acts as the place holder.
The vector adjustment codes contain an map bit selection the map bits go in order to the order the maps are in.
---------------------------------------------------------------------------------------------------------------------------
VEX.mmmmm = 000_00b (1-byte map), 000_01b (2-byte map), 000_10b (0Fh,38h), 000_11b (0Fh,3Ah)
EVEX.mm = 00b (1-byte map), 01b (2-byte map), 10b (0Fh,38h), 11b (0Fh,3Ah)
--------------------------------------------------------------------------------------------------------------------------
Used by function ^DecodeOpcode()^
-------------------------------------------------------------------------------------------------------------------------*/

var Opcode = 0;

/*------------------------------------------------------------------------------------------------------------------------
The Mnemonic array each opcode value has an Instruction Name except for codes that are used as adjustment settings called Prefixes.
Some Opcodes like segment overrides are read and stored into the SegOveride string for the left bracket of the ModR/M address.
Instruction codes may appear multiple times, but use different size attribute adjustments, or change the direction registers, and
memory are used. Some opcode indexes also use Arrays as separators for different selections, and prefixes.
The length of the arrays are to do with encoding selections.
--------------------------------------------------------------------------------------------------------------------------
Used by function ^DecodeOpcode()^
-------------------------------------------------------------------------------------------------------------------------*/

var Mnemonics = [
  //------------------------------------------------------------------------------------------------------------------------
  //First Byte operations
  //------------------------------------------------------------------------------------------------------------------------
  "ADD","ADD","ADD","ADD","ADD","ADD","???","???",
  "OR","OR","OR","OR","OR","OR","???",
  "", //*Two byte instructions prefix
  "ADC","ADC","ADC","ADC","ADC","ADC","???","???",
  "SBB","SBB","SBB","SBB","SBB","SBB","???","???",
  "AND","AND","AND","AND","AND","AND","???","???",
  "SUB","SUB","SUB","SUB","SUB","SUB",
  "CS:[", //Code segment override
  "???",
  "XOR","XOR","XOR","XOR","XOR","XOR",
  "SS:[", //Stack segment override
  "???",
  "CMP","CMP","CMP","CMP","CMP","CMP",
  "DS:[", //Data Segment override
  "???",
  "","","","","","","","","","","","","","","","",//*The Rex Prefix note the REX prefix can now disable in different bit modes allowing these to be used.
  "PUSH","PUSH","PUSH","PUSH","PUSH","PUSH","PUSH","PUSH",
  "POP","POP","POP","POP","POP","POP","POP","POP",
  "???","???","???",
  "MOVSXD",
  "FS:[","GS:[",
  "???","???",
  "PUSH","IMUL","PUSH","IMUL",
  "INS","INS","OUTS","OUTS",
  "JO","JNO","JB","JAE","JE","JNE","JBE","JA",
  "JS","JNS","JP","JNP","JL","JGE","JLE","JG",
  ["ADD","OR","ADC","SBB","AND","SUB","XOR","CMP"],
  ["ADD","OR","ADC","SBB","AND","SUB","XOR","CMP"],
  "???",
  ["ADD","OR","ADC","SBB","AND","SUB","XOR","CMP"],
  "TEST","TEST","XCHG","XCHG",
  "MOV","MOV","MOV","MOV",
  ["MOV","MOV"],
  ["LEA","???"],
  "MOV",
  ["POP","???","???","???","???","???","???","???"],
  ["NOP","NOP","PAUSE","NOP"],"XCHG","XCHG","XCHG","XCHG","XCHG","XCHG","XCHG",
  ["CBW","CWDE","CDQE"],
  ["CWD","CDQ","CQO"],
  "???",
  "WAIT",
  ["PUSHF","PUSHFQ","PUSHFQ"],
  ["POPF","POPFQ","POPFQ"],
  "SAHF","LAHF",
  "MOV","MOV","MOV","MOV",
  "MOVS","MOVS",
  "CMPS","CMPS",
  "TEST","TEST",
  "STOS","STOS",
  "LODS","LODS",
  "SCAS","SCAS",
  "MOV","MOV","MOV","MOV","MOV","MOV","MOV","MOV",
  "MOV","MOV","MOV","MOV","MOV","MOV","MOV","MOV",
  ["ROL","ROR","RCL","RCR","SHL","SHR","SAL","SAR"],
  ["ROL","ROR","RCL","RCR","SHL","SHR","SAL","SAR"],
  "RET","RET",
  "VEX not supported yet!",
  "VEX not supported yet!",
  ["MOV","???","???","???","???","???","???","XABORT"],
  ["MOV","???","???","???","???","???","???","XBEGIN"],
  "ENTER","LEAVE","RETF","RETF","INT","INT","INTO",
  ["IRET","IRETD","IRETQ"],
  ["ROL","ROR","RCL","RCR","SHL","SHR","SAL","SAR"],
  ["ROL","ROR","RCL","RCR","SHL","SHR","SAL","SAR"],
  ["ROL","ROR","RCL","RCR","SHL","SHR","SAL","SAR"],
  ["ROL","ROR","RCL","RCR","SHL","SHR","SAL","SAR"],
  "???","???","???",
  "XLAT",
  //------------------------------------------------------------------------------------------------------------------------
  //X87 FPU
  //------------------------------------------------------------------------------------------------------------------------
  [
    ["FADD","FMUL","FCOM","FCOMP","FSUB","FSUBR","FDIV","FDIVR"],
    ["FADD","FMUL","FCOM","FCOMP","FSUB","FSUBR","FDIV","FDIVR"]
  ],
  [
    ["FLD","???","FST","FSTP","FLDENV","FLDCW","FNSTENV","FNSTCW"],
    [
      "FLD","FXCH",
      ["FNOP","???","???","???","???","???","???","???"],
      "FSTP1",
      ["FCHS","FABS","???","???","FTST","FXAM","???","???"],
      ["FLD1","FLDL2T","FLDL2E","FLDPI","FLDLG2","FLDLN2","FLDZ","???"],
      ["F2XM1","FYL2X","FPTAN","FPATAN","FXTRACT","FPREM1","FDECSTP","FINCSTP"],
      ["FPREM","FYL2XP1","FSQRT","FSINCOS","FRNDINT","FSCALE","FSIN","FCOS"]
    ]
  ],
  [
    ["FIADD","FIMUL","FICOM","FICOMP","FISUB","FISUBR","FIDIV","FIDIVR"],
    [
      "FCMOVB","FCMOVE","FCMOVBE","FCMOVU","???",
      ["???","FUCOMPP","???","???","???","???","???","???"],
      "???","???"
    ]
  ],
  [
    ["FILD","FISTTP","FIST","FISTP","???","FLD","???","FSTP"],
    [
      "CMOVNB","FCMOVNE","FCMOVNBE","FCMOVNU",
      ["FENI","FDISI","FNCLEX","FNINIT","FSETPM","???","???","???"],
      "FUCOMI","FCOMI","???"
    ]
  ],
  [
    ["FADD","FMUL","FCOM","DCOMP","FSUB","FSUBR","FDIV","FDIVR"],
    ["FADD","FMUL","FCOM2","FCOMP3","FSUBR","FSUB","FDIVR","FDIV"]
  ],
  [
    ["FLD","FISTTP","FST","FSTP","FRSTOR","???","FNSAVE","FNSTSW"],
    ["FFREE","FXCH4","FST","FSTP","FUCOM","FUCOMP","???","???"]
  ],

  [
    ["FIADD","FIMUL","FICOM","FICOMP","FISUB","FISUBR","FIDIV","FIDIVR"],
    [
      "FADDP","FMULP","FCOMP5",
      ["???","FCOMPP","???","???","???","???","???","???"],
      "FSUBRP","FSUBP","FDIVRP","FDIVP"
    ]
  ],
  [
    ["FILD","FISTTP","FIST","FISTP","FBLD","FILD","FBSTP","FISTP"],
    [
      "FFREEP","FXCH7","FSTP8","FSTP9",
      ["FNSTSW","???","???","???","???","???","???","???"],
      "FUCOMIP","FCOMIP","???"
    ]
  ],
  //------------------------------------------------------------------------------------------------------------------------
  //End of X87 FPU
  //------------------------------------------------------------------------------------------------------------------------
  "LOOPNE","LOOPE","LOOP","JRCXZ",
  "IN","IN","OUT","OUT",
  "CALL","JMP",
  "???",
  "JMP",
  "IN","IN","OUT","OUT",
  "LOCK",
  "???",
  "REPNE","REP",
  "HLT","CMC",
  ["TEST","???","NOT","NEG","MUL","IMUL","DIV","IDIV"],
  ["TEST","???","NOT","NEG","MUL","IMUL","DIV","IDIV"],
  "CLC","STC","CLI","CTI","CLD","STD",
  ["INC","DEC","???","???","???","???","???","???"],
  [
    ["INC","DEC","CALL","CALL","JMP","JMP","PUSH","???"],
    ["INC","DEC","CALL","???","JMP","???","PUSH","???"]
  ],
  //------------------------------------------------------------------------------------------------------------------------
  //Two Byte operations Opcodes 256 to 511.
  //Opcodes plus 256 goes to 511 used by "0F", Or set directly by adding map bits "01" because "01 00000000" bin = 256 plus opcode.
  //------------------------------------------------------------------------------------------------------------------------
  [
    ["SLDT","STR","LLDT","LTR","VERR","VERW","JMPE","???"],
    ["SLDT","STR","LLDT","LTR","VERR","VERW","JMPE","???"]
  ],
  [
    ["SGDT","SIDT","LGDT","LIDT","SMSW","???","LMSW","INVLPG"],
    [
      ["???","VMCALL","VMLAUNCH","VMRESUME","VMXOFF","???","???","???"],
      ["MONITOR","MWAIT","CLAC","STAC","???","???","???","???"],
      ["XGETBV","XSETBV","???","???","???","XEND","XTEST","???"],
      ["VMRUN","VMMCALL","VMLOAD","VMSAVE","STGI","CLGI","SKINIT","INVLPGA"],
      "SMSW","???","LMSW",
      ["SWAPGS","RDTSCP","MONITORX","MWAITX","???","???","???","???"]
    ]
  ],
  ["LAR","LAR"],["LSL","LSL"],
  "???",
  "SYSCALL","CLTS","SYSRET","INVD",
  "WBINVD","???",
  "UD2","???",
  [["PREFETCH","PREFETCHW","???","???","???","???","???","???"],"???"],
  "FEMMS","???",
  ["MOVUPS","MOVUPD","MOVSS","MOVSD"],
  ["MOVUPS","MOVUPD","MOVSS","MOVSD"],
  [["MOVLPS","MOVLPD","MOVSLDUP","MOVDDUP"],["MOVHLPS","???","MOVSLDUP","MOVDDUP"]],
  [["MOVLPS","MOVLPD","???","???"],["???","???","???","???"]],
  ["UNPCKLPS","UNPCKLPD","???","???"],
  ["UNPCKHPS","UNPCKHPD","???","???"],
  [["MOVHPS","MOVHPD","MOVSHDUP","???"],["MOVLHPS","???","MOVSHDUP","???"]],
  [["MOVHPS","MOVHPD","???","???"],["???","???","???","???"]],
  [["PREFETCHNTA","PREFETCHT0","PREFETCHT1","PREFETCHT2","???","???","???","???"],"???"],
  "???",
  [["BNDLDX","BNDMOV","BNDCL","BNDCU"],["???","BNDMOV","BNDCL","BNDCU"]],
  [["BNDSTX","BNDMOV","BNDMK","BNDCN"],["???","BNDMOV","???","BNDCN"]],
  "???","???","???",
  "NOP",
  ["???","MOV"],["???","MOV"],//CR and DR register Move
  ["???","MOV"],["???","MOV"],//CR and DR register Move
  ["???","MOV"],"???",//TR (TASK REGISTER) register Move
  ["???","MOV"],"???",//TR (TASK REGISTER) register Move
  ["MOVAPS","MOVAPD","???","???"],
  ["MOVAPS","MOVAPD","???","???"],
  ["CVTPI2PS","CVTPI2PD","CVTSI2SS","CVTSI2SD"],
  [["MOVNTPS","MOVNTPD","MOVNTSS","MOVNTSD"],["???","???","???","???"]],
  ["CVTTPS2PI","CVTTPD2PI","CVTTSS2SI","CVTTSD2SI"],
  ["CVTPS2PI","CVTPD2PI","CVTSS2SI","CVTSD2SI"],
  ["UCOMISS","UCOMISD","???","???"],
  ["COMISS","COMISD","???","???"],
  "WRMSR","RDTSC","RDMSR","RDPMC",
  "SYSENTER","SYSEXIT","???",
  "GETSEC",
  "", //*Three byte opcodes 0F38
  "???",
  "", //*Three byte opcodes 0F3A
  "???","???","???","???","???",
  "CMOVO","CMOVNO","CMOVB","CMOVAE","CMOVE","CMOVNE","CMOVBE","CMOVA",
  "CMOVS","CMOVNS","CMOVP","CMOVNP","CMOVL","CMOVGE","CMOVLE","CMOVG",
  [["???","???","???","???"],["MOVMSKPS","MOVMSKPD","???","???"]],
  ["SQRTPS","SQRTPD","SQRTSS","SQRTSD"],
  ["RSQRTPS","???","RSQRTSS","???"],
  ["RCPPS","???","RCPSS","???"],
  ["ANDPS","ANDPD","???","???"],
  ["ANDNPS","ANDNPD","???","???"],
  ["ORPS","ORPD","???","???"],
  ["XORPS","XORPD","???","???"],
  ["ADDPS","ADDPD","ADDSS","ADDSD"],
  ["MULPS","MULPD","MULSS","MULSD"],
  ["CVTPS2PD","CVTPD2PS","CVTSS2SD","CVTSD2SS"],
  ["CVTDQ2PS","CVTPS2DQ","CVTTPS2DQ","???"],
  ["SUBPS","SUBPD","SUBSS","SUBSD"],
  ["MINPS","MINPD","MINSS","MINSD"],
  ["DIVPS","DIVPD","DIVSS","DIVSD"],
  ["MAXPS","MAXPD","MAXSS","MAXSD"],
  ["PUNPCKLBW","PUNPCKLBW","",""],
  ["PUNPCKLWD","PUNPCKLWD","",""],
  ["PUNPCKLDQ","PUNPCKLDQ","",""],
  ["PACKSSWB","PACKSSWB","",""],
  ["PCMPGTB","PCMPGTB","",""],
  ["PCMPGTW","PCMPGTW","",""],
  ["PCMPGTD","PCMPGTD","",""],
  ["PACKUSWB","PACKUSWB","",""],
  ["PUNPCKHBW","PUNPCKHBW","",""],
  ["PUNPCKHWD","PUNPCKHWD","",""],
  ["PUNPCKHDQ","PUNPCKHDQ","",""],
  ["PACKSSDW","PACKSSDW","",""],
  ["???","PUNPCKLQDQ","???","???"],
  ["???","PUNPCKHQDQ","???","???"],
  ["MOVD","MOVD","",""],
  ["MOVQ","MOVDQA","MOVDQU","???"],
  ["PSHUFW","PSHUFD","PSHUFHW","PSHUFLW"],
  [
    "???",
    [
      "???","???",
      ["PSRLW","PSRLW","",""],"???",
      ["PSRAW","PSRAW","",""],"???",
      ["PSLLW","PSLLW","",""],"???"
    ]
  ],
  [
    "???",
    [
      "???","???",
      ["PSRLD","PSRLD","",""],"???",
      ["PSRAD","PSRAD","",""],"???",
      ["PSLLD","PSLLD","",""],"???"
    ]
  ],
  [
    "???",
    [
      "???","???",
      ["PSRLQ","PSRLQ","",""],["???","PSRLDQ","???","???"],
      "???","???",
      ["PSLLQ","PSLLQ","",""],["???","PSLLDQ","???","???"]
    ]
  ],
  ["PCMPEQB","PCMPEQB","",""],
  ["PCMPEQW","PCMPEQW","",""],
  ["PCMPEQD","PCMPEQD","",""],
  "EMMS",
  [
    ["VMREAD","???","???","???"],
    ["VMREAD","EXTRQ","???","INSERTQ"]
  ],
  [
    ["VMWRITE","???","???","???"],
    ["VMWRITE","EXTRQ","???","INSERTQ"]
  ],
  "???","???",
  ["???","HADDPD","???","HADDPS"],
  ["???","HSUBPD","???","HSUBPS"],
  ["MOVD","MOVD","MOVQ","???"],
  ["MOVQ","MOVDQA","MOVDQU","???"],
  "JO","JNO","JB","JAE","JE","JNE","JBE","JA",
  "JS","JNS","JP","JNP","JL","JGE","JLE","JG",
  "SETO","SETNO","SETB","SETAE","SETE","SETNE","SETBE","SETA",
  "SETS","SETNS","SETP","SETNP","SETL","SETGE","SETLE","SETG",
  "PUSH","POP",
  "CPUID",//Identifies the CPU and which Instructions the current CPU can use.
  "BT",
  "SHLD","SHLD",
  "XBTS","IBTS",
  "PUSH","POP",
  "RSM",
  "BTS",
  "SHRD","SHRD",
  [
    [
      ["???","FXSAVE","FXSAVE64"],["???","FXRSTOR","FXRSTOR64"],
      "LDMXCSR","STMXCSR",
      ["","XSAVE","XSAVE64"],["","XRSTOR","XRSTOR64"],
      ["CLWB","XSAVEOPT","XSAVEOPT64"],
      ["CLFLUSHOPT","CLFLUSH",""]
    ],
    [
      ["???","???","RDFSBASE","???"],["???","???","RDGSBASE","???"],
      ["???","???","WRFSBASE","???"],["???","???","WRGSBASE","???"],
      "???",
      ["LFENCE","???","???","???","???","???","???","???"],
      ["MFENCE","???","???","???","???","???","???","???"],
      ["SFENCE","???","???","???","???","???","???","???"]
    ]
  ],
  "IMUL",
  "CMPXCHG","CMPXCHG",
  ["LSS","???"],
  "BTR",
  ["LFS","???"],
  ["LGS","???"],
  "MOVZX","MOVZX",
  ["JMPE","POPCNT","???","???"],
  "???",
  ["???","???","???","???","BT","BTS","BTR","BTC"],
  "BTC",
  ["BSF","???","TZCNT","BSF"],["BSR","???","LZCNT","BSR"],
  "MOVSX","MOVSX",
  "XADD","XADD",
  ["CMPPS","CMPPD","CMPSS","CMPSD"],
  ["MOVNTI","???"],
  [["PINSRW","PINSRW","",""],["PINSRW","PINSRW","",""]],
  [["???","???","???","???"],["PEXTRW","PEXTRW","",""]],
  ["SHUFPS","SHUFPD","???","???"],
  [
    [
      "???",
      ["","CMPXCHG8B","CMPXCHG16B"],
      "???",
      ["","XRSTORS","XRSTORS64"],
      ["","XSAVEC","XSAVEC64"],
      ["","XSAVES","XSAVES64"],
      ["VMPTRLD","VMCLEAR","VMXON","???"],["VMPTRST","???","???","???"]
    ],
    [
      "???",
      "VMGETINFO",
      "???","???","???","???",
      "RDRAND","RDSEED"
    ]
  ],
  "BSWAP","BSWAP","BSWAP","BSWAP","BSWAP","BSWAP","BSWAP","BSWAP",
  ["???","ADDSUBPD","???","ADDSUBPS"],
  ["PSRLW","PSRLW","",""],
  ["PSRLD","PSRLD","",""],
  ["PSRLQ","PSRLQ","",""],
  ["PADDQ","PADDQ","",""],
  ["PMULLW","PMULLW","",""],
  ["???","MOVQ","???","MOVDQ2Q"],
  [["???","???","???","???"],["PMOVMSKB","PMOVMSKB","",""]],
  ["PSUBUSB","PSUBUSB","",""],
  ["PSUBUSW","PSUBUSW","",""],
  ["PMINUB","PMINUB","",""],
  ["PADD","PADD","",""],
  ["PADDUSB","PADDUSB","",""],
  ["PADDUSW","PADDUSW","",""],
  ["PMAXUB","PMAXUB","",""],
  ["PANDN","PANDN","",""],
  ["PAVGB","PAVGB","",""],
  ["PSRAW","PSRAW","",""],
  ["PSRAD","PSRAD","",""],
  ["PAVGW","PAVGW","",""],
  ["PMULHUW","PMULHUW","",""],
  ["PMULHW","PMULHW","",""],
  ["???","CVTTPD2DQ","CVTDQ2PD","CVTPD2DQ"],
  [["MOVNTQ","MOVNTDQ","???","???"],["???","???","???","???"]],
  ["PSUBSB","PSUBSB","",""],
  ["PSUBSW","PSUBSW","",""],
  ["PMINSW","PMINSW","",""],
  ["POR","POR","",""],
  ["PADDSB","PADDSB","",""],
  ["PADDSW","PADDSW","",""],
  ["PMAXSW","PMAXSW","",""],
  ["PXOR","PXOR","",""],
  [["???","???","???","LDDQU"],["???","???","???","???"]],
  ["PSLLW","PSLLW","",""],
  ["PSLLD","PSLLD","",""],
  ["PSLLQ","PSLLQ","",""],
  ["PMULUDQ","PMULUDQ","",""],
  ["PMADDWD","PMADDWD","",""],
  ["PSADBW","PSADBW","",""],
  [["???","???","???","???"],["MASKMOVQ","MASKMOVDQU","???","???"]],
  ["PSUBB","PSUBB","",""],
  ["PSUBW","PSUBW","",""],
  ["PSUBD","PSUBD","",""],
  ["PSUBQ","PSUBQ","",""],
  ["PADDB","PADDB","",""],
  ["PADDW","PADDW","",""],
  ["PADDD","PADDD","",""],
  "???",
  //------------------------------------------------------------------------------------------------------------------------
  //Three Byte operations 0F38.
  //Opcodes plus 512 goes to 767 used by "0F,38", Or set directly by adding map bits "10" because "10 00000000" bin = 512 plus opcode.
  //------------------------------------------------------------------------------------------------------------------------
  ["PSHUFB","PSHUFB","???","???"],
  ["PHADDW","PHADDW","???","???"],
  ["PHADDD","PHADDD","???","???"],
  ["PHADDSW","PHADDSW","???","???"],
  ["PMADDUBSW","PMADDUBSW","???","???"],
  ["PHSUBW","PHSUBW","???","???"],
  ["PHSUBD","PHSUBD","???","???"],
  ["PHSUBSW","PHSUBSW","???","???"],
  ["PSIGNB","PSIGNB","???","???"],
  ["PSIGNW","PSIGNW","???","???"],
  ["PSIGND","PSIGND","???","???"],
  ["PMULHRSW","PMULHRSW","???","???"],
  "???","???","???","???",
  ["???","PBLENDVB","???","???"],
  "???","???","???",
  ["???","BLENDVPS","???","???"],
  ["???","BLENDVPD","???","???"],
  "???",
  ["???","PTEST","???","???"],
  "???","???","???","???",
  ["PABSB","PABSB","???","???"],
  ["PABSW","PABSW","???","???"],
  ["PABSD","PABSD","???","???"],
  "???",
  ["???","PMOVSXBW","???","???"],
  ["???","PMOVSXBD","???","???"],
  ["???","PMOVSXBQ","???","???"],
  ["???","PMOVSXWD","???","???"],
  ["???","PMOVSXWQ","???","???"],
  ["???","PMOVSXDQ","???","???"],
  "???","???",
  ["???","PMULDQ","???","???"],
  ["???","PCMPEQQ","???","???"],
  [["???","MOVNTDQA","???","???"],["???","???","???","???"]],
  ["???","PACKUSDW","???","???"],
  "???","???","???","???",
  ["???","PMOVZXBW","???","???"],
  ["???","PMOVZXBD","???","???"],
  ["???","PMOVZXBQ","???","???"],
  ["???","PMOVZXWD","???","???"],
  ["???","PMOVZXWQ","???","???"],
  ["???","PMOVZXDQ","???","???"],
  "???",
  ["???","PCMPGTQ","???","???"],
  ["???","PMINSB","???","???"],
  ["???","PMINSD","???","???"],
  ["???","PMINUW","???","???"],
  ["???","PMINUD","???","???"],
  ["???","PMAXSB","???","???"],
  ["???","PMAXSD","???","???"],
  ["???","PMAXUW","???","???"],
  ["???","PMAXUD","???","???"],
  ["???","PMULLD","???","???"],
  ["???","PHMINPOSUW","???","???"],
  "???","???","???","???","???","???","???","???","???","???","???","???","???","???","???","???",
  "???","???","???","???","???","???","???","???","???","???","???","???","???","???","???","???",
  "???","???","???","???","???","???","???","???","???","???","???","???","???","???","???","???",
  "???","???","???","???","???","???","???","???","???","???","???","???","???","???",
  [["???","INVEPT","???","???"],["???","???","???","???"]],
  [["???","INVVPID","???","???"],["???","???","???","???"]],
  [["???","INVPCID","???","???"],["???","???","???","???"]],
  "???","???","???","???","???","???","???","???","???","???","???","???","???","???","???","???",
  "???","???","???","???","???","???","???","???","???","???","???","???","???","???","???","???",
  "???","???","???","???","???","???","???","???","???","???","???","???","???","???","???","???",
  "???","???","???","???","???","???","???","???","???","???","???","???","???","???","???","???",
  "???","???","???","???","???","???","???","???","???","???","???","???","???","???","???","???",
  "???","???","???","???","???","???","???","???",
  ["???","AESIMC","???","???"],
  ["???","AESENC","???","???"],
  ["???","AESENCLAST","???","???"],
  ["???","AESDEC","???","???"],
  ["???","AESDECLAST","???","???"],
  "???","???","???","???","???","???","???","???","???","???","???","???","???","???","???","???",
  ["MOVBE","MOVBE","???","CRC32"],["MOVBE","MOVBE","???","CRC32"],
  "???","???","???","???",
  ["???","ADCX","ADOX","???"],
  "???","???","???","???","???","???","???","???","???",
  //------------------------------------------------------------------------------------------------------------------------
  //Three Byte operations 0F3A.
  //Opcodes plus 768 goes to 1023 used by 0F,3A combination, Or set directly by adding map bits 11 by 1100000000 = 768 plus opcode.
  //------------------------------------------------------------------------------------------------------------------------
  "???","???","???","???","???","???","???","???",
  ["???","ROUNDPS","???","???"],
  ["???","ROUNDPD","???","???"],
  ["???","ROUNDSS","???","???"],
  ["???","ROUNDSD","???","???"],
  ["???","BLENDPS","???","???"],
  ["???","BLENDPD","???","???"],
  ["???","PBLENDW","???","???"],
  ["PALIGNR","PALIGNR","???","???"],
  "???","???","???","???",
  [["???","PEXTRB","???","???"],["???","PEXTRB","???","???"]],
  [["???","PEXTRW","???","???"],["???","PEXTRW","???","???"]],
  [
    [
        ["???","PEXTRD","???","???"],
        "???",
        ["???","PEXTRQ","???","???"]
    ],
    [
        ["???","PEXTRD","???","???"],
        "???",
        ["???","PEXTRQ","???","???"]
    ]
  ],
  ["???","EXTRACTPS","???","???"],
  "???","???","???","???","???","???","???","???",
  [["???","PINSRB","???","???"],["???","PINSRB","???","???"]],
  ["???","INSERTPS","???","???"],
  [
    ["???","PINSRD","???","???"],
    "???",
    ["???","PINSRQ","???","???"]
  ],
  "???","???","???","???","???","???","???","???","???","???","???","???","???",
  "???","???","???","???","???","???","???","???","???","???","???","???","???","???","???","???",
  ["???","DPPS","???","???"],
  ["???","DPPD","???","???"],
  ["???","MPSADBW","???","???"],
  "???",
  ["???","PCLMULQDQ","???","???"],
  "???","???","???","???","???","???","???","???","???","???","???",
  "???","???","???","???","???","???","???","???","???","???","???","???","???","???","???","???",
  ["???","PCMPESTRM","???","???"],
  ["???","PCMPESTRI","???","???"],
  ["???","PCMPISTRM","???","???"],
  ["???","PCMPISTRI","???","???"],
  "???","???","???","???","???","???","???","???","???","???","???",
  "???","???","???","???","???","???","???","???","???","???","???","???","???","???","???","???",
  "???","???","???","???","???","???","???","???","???","???","???","???","???","???","???","???",
  "???","???","???","???","???","???","???","???","???","???","???","???","???","???","???","???",
  "???","???","???","???","???","???","???","???","???","???","???","???","???","???","???","???",
  "???","???","???","???","???","???","???","???","???","???","???","???","???","???","???","???",
  "???","???","???","???","???","???","???","???","???","???","???","???","???","???","???","???",
  "???","???","???","???","???","???","???","???","???","???","???","???","???","???","???","???",
  ["???","AESKEYGENASSIST","???","???"],
  "???","???","???","???","???","???","???","???","???","???","???","???","???","???","???","???",
  "???","???","???","???","???","???","???","???","???","???","???","???","???","???","???","???"];

/*------------------------------------------------------------------------------------------------------------------------
The Operand type array each operation code can use different operands that must be decoded in the X86 instruction format order.
The order the operands are "displayed" is the order they are in the Operands string for the operation code.
--------------------------------------------------------------------------------------------------------------------------
Used by function ^DecodeOpcode()^
------------------------------------------------------------------------------------------------------------------------*/

var Operands = [
  //------------------------------------------------------------------------------------------------------------------------
  //First Byte operations
  //------------------------------------------------------------------------------------------------------------------------
  "020107010003","021607160003","070102010003","071602160003","0B0108010003","0B1609060003","","",
  "020107010003","021607160003","070102010003","071602160003","0B0108010003","0B1609060003","","",
  "020107010003","021607160003","070102010003","071602160003","0B0108010003","0B1609060003","","",
  "020107010003","021607160003","070102010003","071602160003","0B0108010003","0B1609060003","","",
  "020107010003","021607160003","070102010003","071602160003","0B0108010003","0B1609060003","","",
  "020107010003","021607160003","070102010003","071602160003","0B0108010003","0B1609060003","","",
  "020107010003","021607160003","070102010003","071602160003","0B0108010003","0B1609060003","","",
  "02010701","02160716","07010201","07160216","0B010801","0B160906","","",
  "","","","","","","","","","","","","","","","",
  "0112","0112","0112","0112","0112","0112","0112","0112",
  "0112","0112","0112","0112","0112","0112","0112","0112",
  "","","",
  "07160204",
  "","","","",
  "0906","071602160906",
  "0901","071602160901",
  "10010D02","10160D02","0D020F01","0D020F16",
  "0A010002000C","0A010002000C","0A010002000C","0A010002000C","0A010002000C","0A010002000C","0A010002000C","0A010002000C",
  "0A010002000C","0A010002000C","0A010002000C","0A010002000C","0A010002000C","0A010002000C","0A010002000C","0A010002000C",
  ["020108010003","020108010003","020108010003","020108010003","020108010003","020108010003","020108010003","02010801"],
  ["021608060003","021608060003","021608060003","021608060003","021608060003","021608060003","021608060003","02160806"],
  "",
  ["021608010003","021608010003","021608010003","021608010003","021608010003","021608010003","021608010003","02160801"],
  "02010701","02160716",
  "070102010003","071602160003",
  "020107010001","021607160001",
  "070102010001","071602160001",
  ["020207000001","021607000001"],
  ["07160200",""],
  "070002020001",
  ["0212","","","","","","",""],
  ["","","",""],"0B1601160003","0B1601160003","0B1601160003","0B1601160003","0B1601160003","0B1601160003","0B1601160003",
  ["","",""],["","",""],
  "","",
  ["","",""],["","",""],
  "","",
  "0B0106010001","0B1606160001",
  "06010B010001","06160B160001",
  "10010F01","10160F16",
  "0F011001","0F161016",
  "0B010801","0B160906",
  "1001","1016","0F01","0F16","1001","1016",
  "010108010001","010108010001","010108010001","010108010001","010108010001","010108010001","010108010001","010108010001",
  "011608160001","011608160001","011608160001","011608160001","011608160001","011608160001","011608160001","011608160001",
  ["02010801","02010801","02010801","02010801","02010801","02010801","02010801","02010801"],
  ["02160801","02160801","02160801","02160801","02160801","02160801","02160801","02160801"],
  "08020004","0004",
  "","",
  ["020108010001","","","","","","","0801"],
  ["021609060001","","","","","","","0A04"],
  "08020801","",
  "0802","","1303",
  "0801","",
  ["","",""],
  ["02011301","02011301","02011301","02011301","02011301","02011301","02011301","02011301"],
  ["02161301","02161301","02161301","02161301","02161301","02161301","02161301","02161301"],
  ["02010C01","02010C01","02010C01","02010C01","02010C01","02010C01","02010C01","02010C01"],
  ["02160C01","02160C01","02160C01","02160C01","02160C01","02160C01","02160C01","02160C01"],
  "","","",
  "1101",
  //------------------------------------------------------------------------------------------------------------------------
  //X87 FPU
  //------------------------------------------------------------------------------------------------------------------------
  [
    ["0304","0304","0304","0304","0304","0304","0304","0304"],
    ["12000304","12000304","0304","0304","12000304","12000304","12000304","12000304"]
  ],
  [
    ["0304","","0304","0304","0300","0302","0300","0302"],
    [
      "0300","0300",
      ["","","","","","","",""],
      "0300",
      ["","","","","","","",""],
      ["","","","","","","",""],
      ["","","","","","","",""],
      ["","","","","","","",""]
    ]
  ],
  [
    ["0304","0304","0304","0304","0304","0304","0304","0304"],
    [
      "12000304","12000304","12000304","12000304","",
      ["","","","","","","",""],"",""
    ]
  ],
  [
    ["0304","0304","0304","0304","","0320","","0320",""],
    [
      "12000304","12000304","12000304","12000304",
      ["","","","","","","",""],
      "12000304","12000304",""
    ]
  ],
  [
    ["0310","0310","0310","0310","0310","0310","0310","0310"],
    ["03101200","03101200","0310","0310","03101200","03101200","03101200","03101200"]
  ],
  [
    ["0310","0310","0310","0310","0310","","0300","0302"],
    ["0310","0310","0310","0310","0310","0310","",""]
  ],
  [
    ["0302","0302","0302","0302","0302","0302","0302","0302"],
    [
      "03021200","03021200","0302",
      ["","","","","","","",""],
      "03021200","03021200","03021200","03021200"
    ]
  ],
  [
    ["0302","0302","0302","0302","0320","0310","0320","0310"],
    [
      "0302","0302","0302","0302",
      ["0B02","","","","","","",""],
      "12000302","12000302",
      ""
    ]
  ],
  //------------------------------------------------------------------------------------------------------------------------
  //End of X87 FPU
  //------------------------------------------------------------------------------------------------------------------------
  "0A010008","0A010008","0A010008","0A010008",
  "0B010801","0B160801",
  "08010B01","08010B16",
  "0A040004","0A0400040008",
  "",
  "0A0100040008",
  "0B010D02","0B160D02",
  "0D020B01","0D020B16",
  "","","","","","",
  ["02010801","","02010003","02010003","0B010201","0201","0B010201","0201"],
  ["02160906","","02160003","02160003","0B160216","0216","0B160216","0B160216"],
  "","","","","","",
  ["02010003","02010003","","","","","",""],
  [
    ["02160003","02160003","02120004","022C0004","02120004","022C0004","0212",""],
    ["02160003","02160003","02120004","","02120004","","0212",""]
  ],
  //------------------------------------------------------------------------------------------------------------------------
  //Two Byte operations
  //------------------------------------------------------------------------------------------------------------------------
  [
    ["0202","0202","0202","0202","0202","0202","0216",""],
    ["0216","0216","0202","0202","0202","0202","0216",""]
  ],
  [
    ["0220","0220","0220","0220","0202","","0202","0200"],
    [
      ["","","","","","","",""],
      ["0B100C100D10","0B100C10","","","","","",""],
      ["","","","","","","",""],
      ["0B10","","0B10","0B10","","","0B04","0B100C04"],
      "0216","","0202",
      ["","","0B100C100D10","0B100C100D10","","","",""]
    ]
  ],
  ["07160202","07160216"],["07160202","07160216"],"",
  "","","","",
  "","","","",
  [["0200","0200","","","","","",""],""],
  "","",
  ["07820540","07820540","07820504","07820510"],
  ["05400782","05400782","05040782","05100782"],
  [["07820210","07820210","07820540","07820510"],["07820540","","07820540","07820510"]],
  [["02100782","02100782","",""],["","","",""]],
  ["07820540","07820540","",""],
  ["07820540","07820540","",""],
  [["07820210","07820210","07820540",""],["07820540","","07820540",""]],
  [["02100782","02100782","",""],["","","",""]],
  [["0200","0200","0200","0200","","","",""],""],
  "",
  [["07860210","07860280","07860210","07860210"],["","07860286","07860210","07860210"]],
  [["02100786","02800786","07860210","07860210"],["","02860786","","07860210"]],
  "","","",
  "0216",
  ["","021007830001"],["","021007840001"],
  ["","078302100001"],["","078402100001"],
  ["","021007850001"],"",
  ["","078502100001"],"",
  ["07820540","07820540","",""],
  ["05400782","05400782","",""],
  ["07820410","07820410","07820214","07820214"],
  [["05400782","05400782","05040782","02100782"],["","","",""]],
  ["07810510","07810540","07140504","07140510"],
  ["07810510","07810540","07140504","07140510"],
  ["07820504","07820510","",""],
  ["07820504","07820510","",""],
  "","","","",
  "","","",
  "",
  "",//Three byte opcodes 0F38
  "",
  "",//Three byte opcodes 0F3A
  "","","","","",
  "07160216","07160216","07160216","07160216","07160216","07160216","07160216","07160216",
  "07160216","07160216","07160216","07160216","07160216","07160216","07160216","07160216",
  [["","","",""],["07040540","07040540","",""]],
  ["07820540","07820540","07820504","07820510"],
  ["07820540","","07820504",""],
  ["07820540","","07820504",""],
  ["07820540","07820540","",""],
  ["07820540","07820540","",""],
  ["07820540","07820540","",""],
  ["07820540","07820540","",""],
  ["07820540","07820540","07820504","07820510"],
  ["07820540","07820540","07820504","07820510"],
  ["07820510","07820540","07820504","07820510"],
  ["07820540","07820540","07820540",""],
  ["07820540","07820540","07820504","07820510"],
  ["07820540","07820540","07820504","07820510"],
  ["07820540","07820540","07820504","07820510"],
  ["07820540","07820540","07820504","07820510"],
  ["07810404","07820540","",""],
  ["07810404","07820540","",""],
  ["07810404","07820540","",""],
  ["07810410","07820540","",""],
  ["07810410","07820540","",""],
  ["07810410","07820540","",""],
  ["07810410","07820540","",""],
  ["07810410","07820540","",""],
  ["07810410","07820540","",""],
  ["07810410","07820540","",""],
  ["07810410","07820540","",""],
  ["07810410","07820540","",""],
  ["","07820540","",""],
  ["","07820540","",""],
  ["07810214","07820214","",""],
  ["07810410","07820540","07820540",""],
  ["078104100801","078205400801","078205400801","078205400801"],
  [
    "",
    [
      "","",
      ["04100801","05400801","",""],"",
      ["04100801","05400801","",""],"",
      ["04100801","05400801","",""],""
    ]
  ],
  [
    "",
    [
      "","",
      ["04100801","05400801","",""],"",
      ["04100801","05400801","",""],"",
      ["04100801","05400801","",""],""
    ]
  ],
  [
    "",
    [
      "","",
      ["04100801","05400801","",""],["","05400801","",""],
      "","",
      ["04100801","05400801","",""],["","05400801","",""]
    ]
  ],
    ["07810410","07820540","",""],
    ["07810410","07820540","",""],
    ["07810410","07820540","",""],
    "",
  [
    ["02100710","","",""],
    ["02100710","078208010801","","0782054008010801"]
  ],
  [
    ["07100210","","",""],
    ["07100210","07820540","","07820540"]
  ],
  "","",
  ["","07820540","","07820540"],
  ["","07820540","","07820540"],
  ["02140781","02140782","07820510",""],
  ["04100781","05400782","05400782",""],
  "0A04000C","0A04000C","0A04000C","0A04000C","0A04000C","0A04000C","0A04000C","0A04000C",
  "0A04000C","0A04000C","0A04000C","0A04000C","0A04000C","0A04000C","0A04000C","0A04000C",
  "0201","0201","0201","0201","0201","0201","0201","0201",
  "0201","0201","0201","0201","0201","0201","0201","0201",
  "1400","1400",
  "",
  "021607160003",
  "021607160801","021607160C01",
  "07160216","02160716",
  "1500","1500",
  "",
  "021607160003",
  "021607160801","021607160C01",
  [
    [
      ["","0200","0200"],["","0200","0200"],
      "0204","0204",
      ["","0200","0200"],["","0200","0200"],
      ["0200","0200","0200"],
      ["0200","0200",""]
    ],
    [
      ["","","0214",""],["","","0214",""],
      ["","","0214",""],["","","0214",""],
      "",
      ["","","","","","","",""],
      ["","","","","","","",""],
      ["","","","","","","",""]
    ]
  ],
  "07160216",
  "020107010003","021607160003",
  ["0716022C",""],
  "021607160003",
  ["0716022C",""],
  ["0716022C",""],
  "07160201","07160202",
  ["0A04","","07060206",""],"",
  ["","","","","021608010003","021608010003","021608010003","021608010003"],
  "071602160003",
  ["07160216","","07160216","07160216"],["07160216","","07160216","07160216"],
  "07160201","07160202",
  "020107010003","021607160003",
  ["078205400801","078205400801","078205040801","078205100801"],
  ["02140714",""],
  [["078102020801","078202020801","",""],["078102040801","078202040801","",""]],
  [["","","",""],["071404100801","071405100801","",""]],
  ["078205400801","078205400801","",""],
  [
    [
      "",
      ["","02100003","02400003"],
      "",
      ["","0200","0200"],
      ["","0200","0200"],
      ["","0200","0200"],
      ["0210","0210","0210",""],["0210","","",""]
    ],
    [
      "",
      "",
      "","","","",
      "0216","0216"
    ]
  ],
  "0116","0116","0116","0116","0116","0116","0116","0116",
  ["","07820540","","07820540"],
  ["07810410","07820540","",""],
  ["07810410","07820540","",""],
  ["07810410","07820540","",""],
  ["07810410","07820540","",""],
  ["07810410","07820540","",""],
  ["","05100782","","07810540"],
  [["","","",""],["07140410","07140540","",""]],
  ["07810410","07820540","",""],
  ["07810410","07820540","",""],
  ["07810410","07820540","",""],
  ["07810410","07820540","",""],
  ["07810410","07820540","",""],
  ["07810410","07820540","",""],
  ["07810410","07820540","",""],
  ["07810410","07820540","",""],
  ["07810410","07820540","",""],
  ["07810410","07820540","",""],
  ["07810410","07820540","",""],
  ["07810410","07820540","",""],
  ["07810410","07820540","",""],
  ["07810410","07820540","",""],
  ["","07820540","07820510","07820540"],
  [["04100781","05400782","",""],["","","",""]],
  ["07810410","07820540","",""],
  ["07810410","07820540","",""],
  ["07810410","07820540","",""],
  ["07810410","07820540","",""],
  ["07810410","07820540","",""],
  ["07810410","07820540","",""],
  ["07810410","07820540","",""],
  ["07810410","07820540","",""],
  [["","","","07820540"],["","","",""]],
  ["07810410","07820540","",""],
  ["07810410","07820540","",""],
  ["07810410","07820540","",""],
  ["07810410","07820540","",""],
  ["07810410","07820540","",""],
  ["07810410","07820540","",""],
  [["","","",""],["07810410","07820540","",""]],
  ["07810410","07820540","",""],
  ["07810410","07820540","",""],
  ["07810410","07820540","",""],
  ["07810410","07820540","",""],
  ["07810410","07820540","",""],
  ["07810410","07820540","",""],
  ["07810410","07820540","",""],
  "",
  //------------------------------------------------------------------------------------------------------------------------
  //Three Byte operations 0F38
  //------------------------------------------------------------------------------------------------------------------------
  ["07810410","07820540","",""],
  ["07810410","07820540","",""],
  ["07810410","07820540","",""],
  ["07810410","07820540","",""],
  ["07810410","07820540","",""],
  ["07810410","07820540","",""],
  ["07810410","07820540","",""],
  ["07810410","07820540","",""],
  ["07810410","07820540","",""],
  ["07810410","07820540","",""],
  ["07810410","07820540","",""],
  ["07810410","07820540","",""],
  "","","","",
  ["","078205401600","",""],
  "","","",
  ["","078205401600","",""],
  ["","078205401600","",""],
  "",
  ["","07820540","",""],
  "","","","",
  ["07810410","07820540","",""],
  ["07810410","07820540","",""],
  ["07810410","07820540","",""],
  "",
  ["","07820510","",""],
  ["","07820504","",""],
  ["","07820502","",""],
  ["","07820510","",""],
  ["","07820504","",""],
  ["","07820510","",""],
  "","",
  ["","07820540","",""],
  ["","07820540","",""],
  [["","07820540","",""],["","","",""]],
  ["","07820540","",""],
  "","","","",
  ["","07820510","",""],
  ["","07820504","",""],
  ["","07820502","",""],
  ["","07820510","",""],
  ["","07820504","",""],
  ["","07820510","",""],
  "",
  ["","07820540","",""],
  ["","07820540","",""],
  ["","07820540","",""],
  ["","07820540","",""],
  ["","07820540","",""],
  ["","07820540","",""],
  ["","07820540","",""],
  ["","07820540","",""],
  ["","07820540","",""],
  ["","07820540","",""],
  ["","07820540","",""],
  "","","","","","","","","","","","","","","","",
  "","","","","","","","","","","","","","","","",
  "","","","","","","","","","","","","","","","",
  "","","","","","","","","","","","","","",
  [["","07140240","",""],["","","",""]],
  [["","07140240","",""],["","","",""]],
  [["","07140240","",""],["","","",""]],
  "","","","","","","","","","","","","","","","",
  "","","","","","","","","","","","","","","","",
  "","","","","","","","","","","","","","","","",
  "","","","","","","","","","","","","","","","",
  "","","","","","","","","","","","","","","","",
  "","","","","","","","",
  ["","07820540","",""],
  ["","07820540","",""],
  ["","07820540","",""],
  ["","07820540","",""],
  ["","07820540","",""],
  "","","","","","","","","","","","","","","","",
  ["07160216","07160216","","07160201"],["02160716","02160716","","07060216"],
  "","","","",
  ["","07140214","07140214",""],
  "","","","","","","","","",
  //------------------------------------------------------------------------------------------------------------------------
  //Three Byte operations 0F3A
  //------------------------------------------------------------------------------------------------------------------------
  "","","","","","","","",
  ["","078205400801","",""],
  ["","078205400801","",""],
  ["","078205400801","",""],
  ["","078205400801","",""],
  ["","078205400801","",""],
  ["","078205400801","",""],
  ["","078205400801","",""],
  ["078104100801","078205400801","",""],
  "","","","",
  [["","020107820801","",""],["","021407820801","",""]],
  [["","020207820801","",""],["","021407820801","",""]],
  [
    [
      ["","020407820801","",""],
      "",
      ["","021007820801","",""]
    ],
    [
      ["","020407820801","",""],
      "",
      ["","021007820801","",""]
    ]
  ],
  ["","021407820801","",""],
  "","","","","","","","",
  [["","078202010801","",""],["","078202040801","",""]],
  ["","078205040801","",""],
  [
    ["","078202040801","",""],
    "",
    ["","078202100801","",""]
  ],
  "","","","","","","","","","","","","",
  "","","","","","","","","","","","","","","","",
  ["","078205400801","",""],
  ["","078205400801","",""],
  ["","078205400801","",""],
  "",
  ["","078205400801","",""],
  "","","","","","","","","","","",
  "","","","","","","","","","","","","","","","",
  ["","078205400801","",""],
  ["","078205400801","",""],
  ["","078205400801","",""],
  ["","078205400801","",""],
  "","","","","","","","","","","",
  "","","","","","","","","","","","","","","","",
  "","","","","","","","","","","","","","","","",
  "","","","","","","","","","","","","","","","",
  "","","","","","","","","","","","","","","","",
  "","","","","","","","","","","","","","","","",
  "","","","","","","","","","","","","","","","",
  "","","","","","","","","","","","","","","","",
  ["","078205400801","",""],
  "","","","","","","","","","","","","","","","",
  "","","","","","","","","","","","","","","",""];

/*-------------------------------------------------------------------------------------------------------------------------
This object stores a single decoded Operand, and gives it an number in "Operand Number" (OperandNum) for the order they are
read in the operand string. It also stores all of the Settings for the operands.
---------------------------------------------------------------------------------------------------------------------------
The order that the operands are in the operand string is different than the order that they read in series by the CPU.
X86 uses a decoder circuit with each operand encoding in series. The "Reg opcode" decodes first if used, then
"ModR/M, SIB, Disp" if ModR/M is used, then Immediate is last. Each encoding that is switched open in series along the
decoder is controlled by the X86 control unit based on the instruction code. The control unit can pick the order to use
the operands, but the order the operands are read in will never change. Each Operand is sorted into an decoder array in
the order they are decoded by the CPU in series.
---------------------------------------------------------------------------------------------------------------------------
The following X86 patent link might help http://www.google.com/patents/US7640417
---------------------------------------------------------------------------------------------------------------------------
Used by function ^DecodeOperandString()^ Which sets the operand active and gives them there settings.
The operands that are set are decoded by the function ^DecodeOperands()^ and after the operands decode they are deactivated.
The order the Operands are in the operand string is the order they will be displayed because OpNum is set the order they are read in.
-------------------------------------------------------------------------------------------------------------------------*/

var Operand = function(){

  return(
    {

      Type:0, //The operand type some operands have different formats like DecodeImmediate() which has a type input.

      BySizeAttrubute:false, //Effects how size is used depends on which operand type for which operand across the decoder array.

      /*-------------------------------------------------------------------------------------------------------------------------
      How Size is used depends on the operand it is along the decoder array for which function it uses to
      decode Like DecodeRegValue(), or Decode_ModRM_SIB_Address(), and lastly DecodeImmediate() as they all take the BySize, and
      Size setting. Each encoding type is extended to 32, then to 64 this allows some instructions to extend while some do not.
      -------------------------------------------------------------------------------------------------------------------------*/

      Size:0x00,

      OperandNum:0, //The operand number basically the order each operand is read in the operand string.

      Active:false, //This is set by the set function not all operand are used across the decoder array.

      //set the operands attributes then set it active in the decoder array.

      Set:function(T, BySize, Settings, OperandNumber)
      {
        this.Type = T;
        this.BySizeAttrubute = BySize;
        this.Size = Settings;
        this.OpNum = OperandNumber; //Give the operand the number it was read in the operand string.
        this.Active = true; //set the operand active so it's settings are decoded by the ^DecodeOperands()^ function.
      },

      //Deactivates the operand after they are decoded by the ^DecodeOperands()^ function.

      Deactivate:function(){ this.Active = false; }
    }
  );

};

/*-------------------------------------------------------------------------------------------------------------------------
The Decoder array is the order each operand is decoded in if used. They are set during the decoding of the operand string
using the function ^DecodeOperandString()^ which also gives each operand an number for the order they are read in.
Then they are decoded by the Function ^DecodeOperands()^ which decodes each set operand across the decoder array in order.
The number the operands are set during the decoding of the operand string for the order they are read is the order they
will be positioned after decoding. As the operands are decoded they are also Deactivated so the next instruction can be
decoded using different operands.
---------------------------------------------------------------------------------------------------------------------------
Uses by functions ^DecodeOperandString()^, and ^DecodeOperands()^.
-------------------------------------------------------------------------------------------------------------------------*/

var X86Decoder = [
  /*-------------------------------------------------------------------------------------------------------------------------
  First operand that is always decoded is "Reg Opcode" if used.
  Uses the function ^DecodeRegValue()^ the input RValue is the three first bits of the opcode.
  -------------------------------------------------------------------------------------------------------------------------*/
  new Operand(), //Reg Opcode if used.
  /*-------------------------------------------------------------------------------------------------------------------------
  The Second operand that is decoded in series is the ModR/M address if used.
  Reads a byte using function ^Decode_ModRM_SIB_Value()^ gives it to the function ^Decode_ModRM_SIB_Address()^ which only
  reads the Mode, and Base register for the address, and then decodes the SIB byte if base register is 100 in value.
  does not use the Register value in the ModR/M because the register can also be used as a group opcode used by the
  function ^DecodeOpcode()^, or uses a different register with a different address pointer.
  -------------------------------------------------------------------------------------------------------------------------*/
  new Operand(), //ModR/M address if used.
  /*-------------------------------------------------------------------------------------------------------------------------
  The third operand that that is decoded if used is for the ModR/M reg bits.
  Uses the already decoded byte from ^Decode_ModRM_SIB_Value()^ gives the three bit reg value to the function ^DecodeRegValue()^.
  ModR/M address, and reg are usually used together, but can also change direction in the encoding string.
  -------------------------------------------------------------------------------------------------------------------------*/
  new Operand(), //ModR/M reg bits if used.
  /*-------------------------------------------------------------------------------------------------------------------------
  The fourth operand that is decoded in sequence is the first Immediate input if used.
  The function ^DecodeImmediate()^ start reading bytes as a number for input to instruction.
  -------------------------------------------------------------------------------------------------------------------------*/
  new Operand(), //First Immediate if used.
  /*-------------------------------------------------------------------------------------------------------------------------
  The fifth operand that is decoded in sequence is the second Immediate input if used.
  The function ^DecodeImmediate()^ start reading bytes as a number for input to instruction.
  -------------------------------------------------------------------------------------------------------------------------*/
  new Operand(), //Second Immediate if used.
  /*-------------------------------------------------------------------------------------------------------------------------
  Vector register if used.
  The Vector extension instruction codes allow the selection of the vector register value that is stored into variable
  VectorRegister that applies to the selected SSE instruction that is read after that uses it.
  The adjusted vector value is given to the function ^DecodeRegValue()^.
  -------------------------------------------------------------------------------------------------------------------------*/
  new Operand(), //Vector register if used. And if vector exstestion is applied to the SSE instruction.
  /*-------------------------------------------------------------------------------------------------------------------------
  Immediate Register encoding if used.
  During the decoding of the immediate operands the ^DecodeImmediate()^ function stores the read IMM into an variable called
  IMMValue. The upper four bits of IMMValue is given to the input RValue to the function ^DecodeRegValue()^.
  -------------------------------------------------------------------------------------------------------------------------*/
  new Operand(), //Immediate Register encoding if used.
  /*-------------------------------------------------------------------------------------------------------------------------
  It does not matter which order the explicit operands decode as they do not require reading another byte.
  Explicit operands are selected internally in the cpu for instruction codes that only use one register, or pointer, or number input.
  -------------------------------------------------------------------------------------------------------------------------*/
  new Operand(), //Explicit Operand one.
  new Operand(), //Explicit Operand two.
  new Operand(), //Explicit Operand three.
  new Operand()  //Explicit Operand four.
];

/*-------------------------------------------------------------------------------------------------------------------------
SizeAttrSelect controls the General arithmetic sizes "8/16/32/64", and SIMD Vector register sizes "128/256/512/1024".
---------------------------------------------------------------------------------------------------------------------------
General arithmetic sizes "8/16/32/64" change by operand override which makes all operands go 16 bit.
The width bit which is in the REX prefix makes operands go all 64 bits the changes depend on the instructions adjustable size.
The value system goes as follows: 0=8, or 16, then 1=Default32, then 2=Max64. Smallest to largest in order.
Changeable from prefixes. Code 66 hex is operand override, 48 hex is the REX.W setting. By default operands are 32 bit
in size in both 32 bit mode, and 64 bit modes so by default the Size attribute setting is 1 in value so it lines up with 32.
In the case of fewer size settings the size system aligns in order to the correct prefix.
---------------------------------------------------------------------------------------------------------------------------
If in 16 bit mode the 16 bit operand size trades places with 32, so when operand override is used goes from 16 to 32.
Also in 32 bit mode any size that is 64 changes to 32, but except for operands that do not use the BySize system.
---------------------------------------------------------------------------------------------------------------------------
During Vector length size settings "128/256/512" the SizeAttrSelect uses the vector length bits as a 0 to 3 value from
smallest to largest Note 1024 is Reserved the same system used for General arithmetic sizes "8/16/32/64" that go in order.
With one difference if any size attribute lower in size like 64, or 32 is active these are used as the Broadcast round size
for memory vector in the EVEX prefix.
---------------------------------------------------------------------------------------------------------------------------
Used by the function ^GetOperandSize()^ which uses a fast logarithm system,
and the function ^DecodeOpcode()^ which uses the current size setting for operation names that change by size.
-------------------------------------------------------------------------------------------------------------------------*/

var SizeAttrSelect = 1;

/*-------------------------------------------------------------------------------------------------------------------------
SSE is set true to allow SSE instructions to be used with vector Extensions such as VEX2, VEX3, and EVEX.
This blocks all other valid Arithmetic opcodes from being combined with vector Extensions that are not SIMD instructions.
This also blocks the ST, and MM X87 FPU registers allowing only the new XMM Vector Registers in SIMD to be used with
Vector Extensions.
---------------------------------------------------------------------------------------------------------------------------
SSE is Set true during the Decoding of operands if Any SSE vector operands are used SIMD Sizes "128/256/512".
If Instruction uses SIMD vectors, and Vector extension is active from the function DecodePrefixAdjustments()
then the instruction is an valid Vector extension.
-------------------------------------------------------------------------------------------------------------------------*/

var SSE = false;

/*-------------------------------------------------------------------------------------------------------------------------
Pointer size plus 16 bit's used by FAR JUMP and other instructions.
For example FAR JUMP is size attributes 16/32/64 normally 32 is the default size, but it is 32+16=48 FWORD PTR.
In 16 bit CPU mode the FAR jump defaults to 16 bits, but because it is a far jump it is 16+16=32 which is DWORD PTR.
---------------------------------------------------------------------------------------------------------------------------
Used by the function ^Decode_ModRM_SIB_Address()^.
-------------------------------------------------------------------------------------------------------------------------*/

var FarPointer = 0;

/*-------------------------------------------------------------------------------------------------------------------------
AddressOverride is hex opcode 67 then when used with any operation that uses the ModR/M in address mode the ram address
goes down one in bit mode. Switches 64 address mode to 32 bit address mode, and in 32 bit mode the address switches to
16 bit address mode which uses a completely different ModR/M format. When in 16 bit mode the address switches to 32 bit.
Set true when Opcode 67 is read by ^DecodePrefixAdjustments()^ which effects the next opcode that is not a prefix opcode
then is set false after instruction decodes.
---------------------------------------------------------------------------------------------------------------------------
Used by the function ^Decode_ModRM_SIB_Address()^.
-------------------------------------------------------------------------------------------------------------------------*/

var AddressOverride = false;

/*-------------------------------------------------------------------------------------------------------------------------
Extended Register value changes by the "R bit" in the REX prefix, or by the "Double R bit" settings in EVEX Extension
which makes the Register operand reach to a max value of 32 registers along the register array.
Normally the Register selection in ModR/M, and Reg Opcode is limited to three bits in binary 000 = 0 to 111 = 7.
RegExtend stores the two binary bits that are added onto the three bit register selection.
---------------------------------------------------------------------------------------------------------------------------
When RegExtend is 00,000 the added lower three bits is 00,000 = 0 to 00,111 = 7.
When RegExtend is 01,000 the added lower three bits is 01,000 = 8 to 01,111 = 15.
When RegExtend is 10,000 the added lower three bits is 10,000 = 16 to 10,111 = 23.
When RegExtend is 11,000 the added lower three bits is 11,000 = 24 to 10,111 = 31.
---------------------------------------------------------------------------------------------------------------------------
The Register Extend bits make the binary number from a 3 bit number to a 5 bit number by combining the EVEX.R'R bits.
---------------------------------------------------------------------------------------------------------------------------
Used by function ^DecodeRegValue()^.
-------------------------------------------------------------------------------------------------------------------------*/

var RegExtend = 0;

/*-------------------------------------------------------------------------------------------------------------------------
The base register is used in ModR/M address mode, and Register mode and can be extended to 8 using the "B bit" setting
from the REX prefix, or VEX Extension, and EVEX Extension, however in EVEX the tow bits "X, and B" are used together to
make the base register reach 32 in register value if the ModR/M is in Register mode.
---------------------------------------------------------------------------------------------------------------------------
The highest the Base Register can be extended is from a 3 bit number to a 5 bit number.
---------------------------------------------------------------------------------------------------------------------------
Used by the function ^Decode_ModRM_SIB_Address()^.
-------------------------------------------------------------------------------------------------------------------------*/

var BaseExtend = 0;

/*-------------------------------------------------------------------------------------------------------------------------
The index register is used in ModR/M memory address mode if the base register is "100" bin in the ModR/M which sets SIB mode.
The Index register can be extended to 8 using the "X bit" setting when the Index register is used.
The X bit setting is used in the REX prefix settings, and also the VEX Extension, and EVEX Extension.
---------------------------------------------------------------------------------------------------------------------------
The highest the Index Register can be extended is from a 3 bit number to a 4 bit number.
---------------------------------------------------------------------------------------------------------------------------
Used by the function ^Decode_ModRM_SIB_Address()^.
-------------------------------------------------------------------------------------------------------------------------*/

var IndexExtend = 0;

/*-------------------------------------------------------------------------------------------------------------------------
The VEX Extension, and EVEX Extension have an Vector register selection built in for SSE operation codes that use the
vector register. This operand will not be read in the "operand string" if VEX, or EVEX prefix was not decoded in the
function ^DecodePrefixAdjustments()^. During a VEX, or EVEX version of the SSE instruction the vector bits are a 4 bit
binary value of 0 to 15, and are extended in EVEX to 32 by adding the EVEX.V bit to the vector register value.
---------------------------------------------------------------------------------------------------------------------------
Used with the function ^DecodeRegValue()^.
-------------------------------------------------------------------------------------------------------------------------*/

var VectorRegister = 0;

/*-------------------------------------------------------------------------------------------------------------------------
The EVEX Extension has an mask Register value selection for {K0-K7} mask to destination operand.
The K mask register is always displayed to the destination operand in any Vector instruction used with EVEX settings.
-------------------------------------------------------------------------------------------------------------------------*/

var MaskRegister = 0;

/*-------------------------------------------------------------------------------------------------------------------------
The EVEX Extension has an zero mask bit setting for {z} zeroing off the registers.
-------------------------------------------------------------------------------------------------------------------------*/

var ZeroMerg = false;

/*-------------------------------------------------------------------------------------------------------------------------
SegOverride is the bracket that is added onto the start of the decoded address it is designed this way so that if a segment
Override Prefix is used it is stored with the segment.
---------------------------------------------------------------------------------------------------------------------------
used by function ^Decode_ModRM_SIB_Address()^.
-------------------------------------------------------------------------------------------------------------------------*/

var SegOverride = "[";

/*-------------------------------------------------------------------------------------------------------------------------
The EVEX Extension has an broadcast rounding system in which some operations support "B32{1to16}, B64{1to8}".
---------------------------------------------------------------------------------------------------------------------------
During Vector length size settings "128/256/512" the SizeAttrSelect uses the vector length bits as a 0 to 3 value from
smallest to largest Note 1024 is Reserved the same system used for General arithmetic sizes "8/16/32/64" that go in order.
With one difference if any size attribute lower in size like 64, or 32 is active these are used as the Broadcast round size
for memory vector in the EVEX prefix.
---------------------------------------------------------------------------------------------------------------------------
Used by the function ^GetOperandSize()^, and the function ^Decode_ModRM_SIB_Address()^.
-------------------------------------------------------------------------------------------------------------------------*/

var BRound = false;

/*-------------------------------------------------------------------------------------------------------------------------
The Width Bit is used differently in vector extended instructions as a separator in the opcode map for more operations.
--------------------------------------------------------------------------------------------------------------------------
Used by function ^DecodeOpcode()^.
-------------------------------------------------------------------------------------------------------------------------*/

var WidthBit = 0;

/*-------------------------------------------------------------------------------------------------------------------------
This may seem confusing, but the 8 bit high low registers are used all in "low order" when any REX prefix is used.
Set RexActive true when the REX Prefix is used, for the High, and low Register separation.
---------------------------------------------------------------------------------------------------------------------------
Used by function ^DecodeRegValue()^
-------------------------------------------------------------------------------------------------------------------------*/

var RexActive = false;

/*-------------------------------------------------------------------------------------------------------------------------
The SIMD value is set according to SIMD MODE for SSE prefixes (none, 66, F2, F3), then by value of VEX.pp, and EVEX.pp.
Changes the selected opcode in ^DecodeOpcode()^ function.
---------------------------------------------------------------------------------------------------------------------------
Used by the function ^DecodeOpcode()^
-------------------------------------------------------------------------------------------------------------------------*/

var SIMD = 0;

/*-------------------------------------------------------------------------------------------------------------------------
Some operands use the value of the Immediate operand as an opcode, or upper 4 bits as Another register, or condition codes.
The Immediate is decoded normally, but this variable stores the integer value of the first IMM byte for the other byte
encodings if used.
-------------------------------------------------------------------------------------------------------------------------*/

var IMMValue = 0;

/*-------------------------------------------------------------------------------------------------------------------------
Prefix G1, and G2 are used used with Intel HLE.
-------------------------------------------------------------------------------------------------------------------------*/

var PrefixG1 = "", PrefixG2 = "";

/*-------------------------------------------------------------------------------------------------------------------------
Intel HLE flip "G1 = REP (XACQUIRE), or RENP (XRELEASE)", and "G2 = LOCK" if the lock prefix was not read first. G1, and G2 flip.
Also XACQUIRE, and XRELEASE replace REP, and REPNE if the LOCK prefix is used with REP, or REPNE.
Also the instruction has to support Intel HLE.
-------------------------------------------------------------------------------------------------------------------------*/

var HLEFlipG1G2 = false;

/*-------------------------------------------------------------------------------------------------------------------------
The Invalid Instruction variable is very important as some bit settings in vector extension create invalid operation codes.
Also some opcodes are invalid in different cpu bit modes.
-------------------------------------------------------------------------------------------------------------------------*/

var InvalidOp = false;

/*-------------------------------------------------------------------------------------------------------------------------
The Register array holds arrays in order from 0 though 7 for the GetOperandSize function Which goes by Prefix size settings,
and SIMD Vector length instructions.
-------------------------------------------------------------------------------------------------------------------------*/

REG = [

  /*REG array Index 0 Is used only if the value returned from the GetOperandSize is 0 in value which is the 8 bit size names
  and selection of the general use Arithmetic registers. However this array element has two arrays of 8 bit registers
  The reason is that the Register names change under 8 bit register selection if any rex prefix is used reason is explained bellow.*/

  [
    //8 bit registers without any rex prefix active is the normal low byte to high byte order of the first 4 general use registers using 8 bits.

    [
      //Registers 8 bit names without any rex prefix index 0 to 7

      "AL", "CL", "DL", "BL", "AH", "CH", "DH", "BH"
    ],

    //8 bit registers with any rex prefix active uses all 15 registers in low byte order.

    [
      //Registers 8 bit names with any rex prefix index 0 to 7

      "AL", "CL", "DL", "BL", "SPL", "BPL", "SIL", "DIL",

      /*Registers 8 bit names Extended using the REX.R extends setting in the Rex prefix, or VEX.R bit, or EVEX.R.
      What ever RegExtend is set based on prefix settings is added to the select Reg Index*/

      "R8B", "R9B", "R10B", "R11B", "R12B", "R13B", "R14B", "R15B"
    ]
  ],

  /*REG array Index 1 Is used only if the value returned from the GetOperandSize is 1 in value
  which bellow is the general use Arithmetic register names 16 in size*/

  [
    //Registers 16 bit names index 0 to 15

    "AX", "CX", "DX", "BX", "SP", "BP", "SI", "DI", "R8W", "R9W", "R10W", "R11W", "R12W", "R13W", "R14W", "R15W"
  ],

  /*REG array Index 2 Is used only if the value from the GetOperandSize function is 2 in value
  which bellow is the general use Arithmetic register names 32 in size*/

  [
    //Registers 32 bit names index 0 to 15

    "EAX", "ECX", "EDX", "EBX", "ESP", "EBP", "ESI", "EDI", "R8D", "R9D", "R10D", "R11D", "R12D", "R13D", "R14D", "R15D"
  ],

  /*REG array Index 3 Is used only if the value returned from the GetOperandSize is 3 in value
  which bellow is the general use Arithmetic register names 64 in size*/

  [
    //general use Arithmetic registers 64 names index 0 to 15

    "RAX", "RCX", "RDX", "RBX", "RSP", "RBP", "RSI", "RDI", "R8", "R9", "R10", "R11", "R12", "R13", "R14", "R15"
  ],

  //REG array Index 4 SIMD registers 128 in size.

  [
    //Register XMM names index 0 to 15

    "XMM0", "XMM1", "XMM2", "XMM3", "XMM4", "XMM5", "XMM6", "XMM7", "XMM8", "XMM9", "XMM10", "XMM11", "XMM12", "XMM13", "XMM14", "XMM15",

    //Register XMM names index 16 to 31 (Note different bit EVEX prefixes allow higher Extension values in the Register Extend variables)

    "XMM16", "XMM17", "XMM18", "XMM19", "XMM20", "XMM21", "XMM22", "XMM23", "XMM24", "XMM25", "XMM26", "XMM27", "XMM28", "XMM29", "XMM30", "XMM31"
  ],

  //REG array Index 5 SIMD registers 256 in size.

  [
    //Register YMM names index 0 to 15

    "YMM0", "YMM1", "YMM2", "YMM3", "YMM4", "YMM5", "YMM6", "YMM7", "YMM8", "YMM9", "YMM10", "YMM11", "YMM12", "YMM13", "YMM14", "YMM15",

    //Register YMM names index 16 to 31 (Note different bit EVEX prefixes allow higher Extension values in the Register Extend variables)

    "YMM16", "YMM17", "YMM18", "YMM19", "YMM20", "YMM21", "YMM22", "YMM23", "YMM24", "YMM25", "YMM26", "YMM27", "YMM28", "YMM29", "YMM30", "YMM31"
  ],

  //REG array Index 6 SIMD registers 512 in size.

  [
    //Register ZMM names index 0 to 15

    "ZMM0", "ZMM1", "ZMM2", "ZMM3", "ZMM4", "ZMM5", "ZMM6", "ZMM7", "ZMM8", "ZMM9", "ZMM10", "ZMM11", "ZMM12", "ZMM13", "ZMM14", "ZMM15",

    //Register ZMM names index 16 to 31 (Note different bit EVEX prefixes allow higher Extension values in the Register Extend variables)

    "ZMM16", "ZMM17", "ZMM18", "ZMM19", "ZMM20", "ZMM21", "ZMM22", "ZMM23", "ZMM24", "ZMM25", "ZMM26", "ZMM27", "ZMM28", "ZMM29", "ZMM30", "ZMM31"
  ],

  //REG array Index 7 SIMD registers 1024 bit (Reserved)

  [
    //Register unknowable names index 0 to 15

    "?MM0", "?MM1", "?MM2", "?MM3", "?MM4", "?MM5", "?MM6", "?MM7", "?MM8", "?MM9", "?MM10", "?MM11", "?MM12", "?MM13", "?MM14", "?MM15",

    //Register unknowable names index 16 to 31 (Note different bit EVEX prefixes allow higher Extension values in the Register Extend variables)

    "?MM16", "?MM17", "?MM18", "?MM19", "?MM20", "?MM21", "?MM22", "?MM23", "?MM24", "?MM25", "?MM26", "?MM27", "?MM28", "?MM29", "?MM30", "?MM31"
  ],

  /*The Registers bellow this line do not change size they are completely separate registers used for special purposes that have one single size.
  These registers are selected by index based on the setting number value instead of size attributes used by GetOperandSize.
  every function has been set up to go by both size attributes and by one strict size setting which is used as a number for the selected index.
  When the BySize adjustment is false.*/

  //REG array Index 8

  [
    //Segment Registers names index 0 to 7

    "ES", "CS", "SS", "DS", "FS", "GS", "ST(-2)", "ST(-1)"
  ],

  //REG array Index 9

  [
    //ST registers Names index 0 to 7
    //note these are used with the X87 FPU, but are aliased to MM in SIMD.

    "ST(0)", "ST(1)", "ST(2)", "ST(3)", "ST(4)", "ST(5)", "ST(6)", "ST(7)"
  ],

  //REG index 10 Intel MM qword technology MMX vector instructions.
  //These can not be used with Vector extensions as they are the ST registers, but use the SIMD unit.
  //The new XMM registers that where added during SSE can be adjusted by vector length as they are separate,
  //but still use the same SIMD unit.

  [
    //Register MM names index 0 to 7

    "MM0", "MM1", "MM2", "MM3", "MM4", "MM5", "MM6", "MM7"
  ],

  //REG Array Index 11

  [
    //BND0 to BND3,and CR0 to CR3 for two byte opcodes 0x0F1A,and 0x0F1B register index 0 to 7

    "BND0", "BND1", "BND2", "BND3", "CR0", "CR1", "CR2", "CR3"
  ],

  //REG array Index 12

  [
    //control Registers index 0 to 15

    "CR0", "CR1", "CR2", "CR3", "CR4", "CR5", "CR6", "CR7", "CR8", "CR9", "CR10", "CR11", "CR12", "CR13", "CR14", "CR15"
  ],

  //REG array Index 13

  [
    //debug registers index 0 to 15

    "DR0", "DR1", "DR2", "DR3", "DR4", "DR5", "DR6", "DR7", "DR8", "DR9", "DR10", "DR11", "DR12", "DR13", "DR14", "DR15"
  ],

  //REG array Index 14

  [
    //TR registers index 0 to 7

    "TR0", "TR1", "TR2", "TR3", "TR4", "TR5", "TR6", "TR7"
  ],

  //REG Array Index 15 uses the K registers.

  [
    //K registers index 0 to 7

    "K0", "K1", "K2", "K3", "K4", "K5", "K6", "K7"
  ]

]; //end of REG array structure

/*--------------------------------------------------------------------------------------------------
RAM Pointer sizes are controlled by the GetOperandSize function which uses the Size Setting attributes for
the select pointer in the PTR array alignment. The REG array above uses the same alignment to the returned
size attribute except address pointers have far address pointers which are 16 bits plus there (8, or 16)/32/64 size attribute.
----------------------------------------------------------------------------------------------------
Far pointers add 16 bits to the default pointer sizes.
16 bits become 16+16=32 DWORD, 32 bits becomes 32+16=48 FWORD, and 64+16=80 TBYTE.
The function GetOperandSize goes 0=8 bit, 1=16 bit, 2=32 bit, 3=64 bit, 4=128, 5=256, 6=512, 7=1024.
----------------------------------------------------------------------------------------------------
The pointers are stored in doubles this is so every second position is each size setting.
So the Returned size attribute has to be in multiples of 2 each size multiplied by 2 looks like this.
(0*2=0)=8 bit, (1*2=2)=16 bit, (2*2=4)=32 bit, (3*2=6)=64 bit, (4*2=8)=128, (5*2=10)=256, (6*2=12)=512.
This is the same as moving by 2 this is why each pointer is in groups of two before the next line.
When the 16 bit shift is used for far pointers only plus one is added for the 16 bit shifted name of the pointer.
----------------------------------------------------------------------------------------------------
Used by the function ^Decode_ModRM_SIB_Address()^.
--------------------------------------------------------------------------------------------------*/

PTR = [

  //Pointer array index 0 when GetOperandSize returns size 0 then times 2 for 8 bit pointer.
  //In plus 16 bit shift array index 0 is added by 1 making 0+1=1 no pointer name is used.
  //The blank pointer is used for instructions like LEA which loads the effective address.
  "BYTE PTR ", "",

  //Pointer array index 2 when GetOperandSize returns size 1 then times 2 for 16 bit pointer alignment.
  //In plus 16 bit shift index 2 is added by 1 making 2+1=3 The 32 bit pointer name is used (mathematically 16+16=32).
  "WORD PTR ", "DWORD PTR ",

  //Pointer array index 4 when GetOperandSize returns size 2 then multiply by 2 for index 4 for the 32 bit pointer.
  //In plus 16 bit shift index 4 is added by 1 making 4+1=5 the 48 bit Far pointer name is used (mathematically 32+16=48).
  "DWORD PTR ", "FWORD PTR ",

  //Pointer array index 6 when GetOperandSize returns size 3 then multiply by 2 gives index 6 for the 64 bit pointer.
  //The Non shifted 64 bit pointer has two types the 64 bit vector "MM", and regular "QWORD" the same as the REG array.
  //In plus 16 bit shift index 6 is added by 1 making 6+1=7 the 80 bit TBYTE pointer name is used (mathematically 64+16=80).
  "QWORD PTR ", "TBYTE PTR ",

  //Pointer array index 8 when GetOperandSize returns size 4 then multiply by 2 gives index 8 for the 128 bit Vector pointer.
  //In far pointer shift the MMX vector pointer is used.
  //MM is desinged to be used when the by size system is false using index 9 for Pointer, and index 10 for Reg.
  "XMMWORD PTR ",  "MMWORD PTR ",

  //Pointer array index 10 when GetOperandSize returns size 5 then multiply by 2 gives index 10 for the 256 bit SIMD pointer.
  //In far pointer shift the OWORD pointer is used with the bounds instructions it is also designed to be used when the by size is set false same as MM.
  "YMMWORD PTR ", "OWORD PTR ",

  //Pointer array index 12 when GetOperandSize returns size 6 then multiply by 2 gives index 12 for the 512 bit pointer.
  //In plus 16 bit shift index 12 is added by 1 making 12+1=13 there is no 528 bit pointer name (mathematically 5126+16=528).
  "ZMMWORD PTR ", "ERROR PTR ",

  //Pointer array index 14 when GetOperandSize returns size 7 then multiply by 2 gives index 12 for the 1024 bit pointer.
  //In plus 16 bit shift index 14 is added by 1 making 12+1=13 there is no 1 bit pointer name (mathematically 5126+16=528).
  "?MMWORD PTR ", "ERROR PTR "];

/*-------------------------------------------------------------------------------------------------------------------------
SIB byte scale Note the Scale bits value is the selected index of the array bellow only used under
a Memory address that uses the SIB Address mode which uses another byte for the address selection.
---------------------------------------------------------------------------------------------------------------------------
used by the ^Decode_ModRM_SIB_Address function^.
-------------------------------------------------------------------------------------------------------------------------*/

var scale = [
 "", //when scale bits are 0 in value no scale multiple is used
 "*2", //when scale bits are 1 in value a scale multiple of times two is used
 "*4", //when scale bits are 2 in value a scale multiple of times four is used
 "*8"  //when scale bits are 3 in value a scale multiple of times eight is used
 ];

/*-------------------------------------------------------------------------------------------------------------------------
This function moves the simulated 64 bit address by one and caries to the 64 bit section of the simulated address when the
end of the 32 bit int is reached. This function also moves the binary code array position CodePos32 by one basically this
function is used to progress the disassembler as it is decoding a sequence of bytes.
-------------------------------------------------------------------------------------------------------------------------*/

function NextByte(){

  Pos32 += 1;

  //if the first 32 bits of the simulated 64 bit address position is grater than a max 32 bit value carry to Pos64.

  if (Pos32 > 0xFFFFFFFF)
  {
    Pos32 = 0x00000000;
    Pos64 += 1;
  }

  //if the carry 64 bit address reaches it's end the default behavior of the 64 bit instruction pointer register is
  //to start back at 0.

  if (Pos64 > 0xFFFFFFFF)
  {
    Pos64 = 0x00000000;
  }

  //add the 32 bit array index position by one for the binary code array

  CodePos32 += 1;

  //if the code position reaches the end of the array index

  if (CodePos32 > 0xFFFFFFFF)
  {
    CodePos = 0; //for now lets just set it 0 without adding in the binary disk read library
  }

  //Add the next byte as a hex to InstructionHex which will be displayed beside the decoded instruction.
  //Add hex codes to InstructionHex only if ShowInstructionHex decoding is active.
  //After an instruction decodes InstructionHex is reset for the next byte sequence for the next instruction.

  if (ShowInstructionHex)
  {
    var t = BinCode[CodePos32].toString(16); //convert the byte to hex.
    if (t.length == 1) { t = "0" + t; } //pad it to tow hex digits as a byte.
    InstructionHex += t; //add it to the current bytes used for the decode instruction.
    t = null; //set the temporary string used for padding it to a hex byte null.
  }

};

/*-------------------------------------------------------------------------------------------------------------------------
Takes a 64 bit hex string and sets it as the 64 address position.
-------------------------------------------------------------------------------------------------------------------------*/

function SetBasePosition(Address64){
    Pos32 = parseInt(Address64.slice(-8), 16);
    Pos64 = parseInt(Address64.substring(0, Address64.length - 8), 16);};

/*-------------------------------------------------------------------------------------------------------------------------
gives back the current 64 bit address position.
-------------------------------------------------------------------------------------------------------------------------*/

function GetPosition(){
    for (var S32 = Pos32.toString(16) ; S32.length < 8; S32 = "0" + S32);
    for (var S64 = Pos64.toString(16) ; S64.length < 8; S64 = "0" + S64);
    return ((S64 + S32).toUpperCase());};

/*-------------------------------------------------------------------------------------------------------------------------
finds bit positions to the Size attribute indexes in REG array, and Pointer Array. For the Size Attribute variations.
-------------------------------------------------------------------------------------------------------------------------*/

function GetOperandSize(SizeAttribute){

    //Log 2

    var p2 = Math.log(2);

    //Most Significant bit is the log of 2 Floored, thus gives bit position.
    //The highest size setting attribute biggest to smallest order S1 to S3.

    var S1 = (Math.floor((Math.log(SizeAttribute) / p2)));

    //convert the Bit Position of the log into it's value and remove it by subtracting it.

    SizeAttribute -= Math.pow(2, S1);

    //----------------------------------------------------------------------------------------------------------------------------------------
    //If Max size is 128 or bigger Vectors use the smaller 64, and 32 Attribute to Broadcast round.
    //----------------------------------------------------------------------------------------------------------------------------------------

    if(S1 >= 4)
    {
      var BRoundAttr = SizeAttribute & 0x0F; //bit attributes 64 and lower.

      //If Broadcast round is active return the Attribute bit position only if BRoundAttr has an bit setting and is not 0.

      if(BRound)
      {
        if(BRoundAttr != 0)
        {
          return(Math.floor((Math.log(BRoundAttr) / p2))); //return Bit position.
        }

        //else Broadcast round is invalid for the pointer address return -1.

        else { return(-1); }

      }

      SizeAttribute -= BRoundAttr; //If Broadcast round is not active remove it from the Size Attributes.
    }

    //find the Second Most Significant bit Size setting.

    var S2 = (Math.floor((Math.log(SizeAttribute) / p2)));

    //Remove the found bit position size.

    SizeAttribute -= Math.pow(2, S2);

    //find the third Most Significant bit Size setting.

    var S3 = (Math.floor((Math.log(SizeAttribute) / p2)));

    //----------------------------------------------------------------------------------------------------------------------------------------
    //If there is no size attributes then set S1 to -1 then the rest are set to S1 as they should have no size setting.
    //----------------------------------------------------------------------------------------------------------------------------------------

    if (S1 == Number.NEGATIVE_INFINITY) { S1 = -1; }

    //----------------------------------------------------------------------------------------------------------------------------------------
    //The Operand Override Size attribute is aliased to S1 if no Size setting attribute for S2.
    //----------------------------------------------------------------------------------------------------------------------------------------

    if (S2 == Number.NEGATIVE_INFINITY) { S2 = S1; }

    //----------------------------------------------------------------------------------------------------------------------------------------
    //If there is no Third size attribute then Size attributes shift down. This is so the smaller size is the lower size attribute.
    //----------------------------------------------------------------------------------------------------------------------------------------

    if (S3 == Number.NEGATIVE_INFINITY) { S3 = S2; S2 = S1; }

    //In 32/16 bit mode the operand size must never exceed 32.

    if (BitMode <= 1 & S2 == 3){ S2 = 2; }

    //In 16 bit mode The operand override is always active until used. This makes all operands 16 bit size.
    //When Operand override is used it is the default 32 size. Flip S3 with S2.

    if(BitMode == 0) { var t = S3; S3 = S2; S2 = t; t = null; }

    //note the fourth size that is -1 in the returned size attribute is Vector length 11=3 which is invalid unless Intel decides to add 1024 bit vectors.

    return( ( [S3, S2, S1, -1] )[SizeAttrSelect] );

};

/*-------------------------------------------------------------------------------------------------------------------------
This function returns an int array with three elements.
---------------------------------------------------------------------------------------------------------------------------
The first element is the two bits for the ModR/M byte, or the SIB byte scale as a number value 0 to 3
The second element is the three bits for the ModR/M byte Opcode/Reg bits, or the SIB Index Register value as a number value 0 to 7
The third element is the last three bits for the ModR/M byte the R/M bits, or the SIB Base Register value as a number value 0 to 7
-------------------------------------------------------------------------------------------------------------------------*/

function Decode_ModRM_SIB_Value(){

    //Get the current position byte value

    var v = BinCode[CodePos32];

    //The first tow binary digits of the read byte is the Mode bits of the ModR/M byte or
    //The first tow binary digits of the byte is the Scale bits of the SIB byte

    var ModeScale = (v >> 6) & 0x03; //value 0 to 3

    //The three binary digits of the read byte after the first two digits is the OpcodeReg Value of the ModR/M byte or
    //The three binary digits of the read byte after the first two digits is the Index Register value for the SIB byte

    var OpcodeRegIndex = (v >> 3) & 0x07; //value 0 to 7

    //The three binary digits at the end of the read byte is the R/M (Register,or Memory) Value of the ModR/M byte or
    //The three binary digits at the end of the read byte is the Base Register Value of the SIB byte

    var RMBase = v & 0x07; //value 0 to 7

    //Put the array together containing the three indexes with the value
    //Note both the ModR/M byte and SIB byte use the same bit value pattern

    var ByteValueArray = [
      ModeScale,//Index 0 is the first tow bits for the Mode, or Scale Depending on what the byte value is used for.
      OpcodeRegIndex,//Index 1 is the three bits for the OpcodeReg, or Index Depending on what the byte value is used for.
      RMBase //Index 2 is the three bits for the RM, or BASE bits Depending on what the byte value is used for.
    ];

    //Move the Decoders Position by one.

    NextByte();

    //return the array containing the decoded values of the byte.

    return (ByteValueArray);

};

/*-------------------------------------------------------------------------------------------------------------------------
When input type is value 0 decode the immediate input regularly to it's size setting for accumulator Arithmetic, and IO.
When input type is value 1 decode the immediate input regularly, but zeros out the upper 4 bits for Register encoding.
When input type is value 2 decode the immediate as a relative address used by jumps, and function calls.
When input type is value 3 decode the immediate as a Integer Used by Displacements.
---------------------------------------------------------------------------------------------------------------------------
The function argument SizeSetting is the size attributes of the IMM that is decoded using the GetOperandSize function.
The Imm uses two size setting, the first 4 bits are used for the Immediate actual adjustable sizes 8,16,32,64.
The second 4 bits is padding for sizes 8,16,32,64 to match destination operand for if the imm does not adjust bigger into
the bigger destination.
---------------------------------------------------------------------------------------------------------------------------
If BySize is false the SizeSetting is used numerically as a single size selection as
0=8,1=16,2=32,3=64 by size setting value.
-------------------------------------------------------------------------------------------------------------------------*/

function DecodeImmediate(type, BySize, SizeSetting){

    var imm = ""; //this will store each byte in reverse order for little endian format as a hex string

    var S = SizeSetting & 0x0F; //Size is SizeSetting unless BySize is true.
    var PAD = SizeSetting >> 4; //PAD is SizeSetting unless BySize is true.

    if(BySize)
    {

        S = GetOperandSize(S); //holds the decoded size setting value.

        PAD = S; //PAD is current size unless the Size Setting has Size settings for pad sizes.

        if (SizeSetting > 0x0F) //if higher 4 bits is used then go by size attribute for Immediate Sizes that have to be padded to.
        {
            PAD = GetOperandSize(PAD); //PAD is size unless the Size Setting has Size settings it can pad till.
        }

    }

    //the possible values of S are S=0 IMM8, S=1 IMM16, S=2 IMM32, S=3 IMM64.
    //calculate how many bytes that are going to have to be read based on the value of S
    //S=0 is 1 byte, S=1 is 2 bytes, S=2 is 4 bytes, S=3 is 8 bytes

    var n = Math.pow( 2, S ); //The Number of bytes to read is 2 to the power of S.

    //store the byte of the immediate because IMM8 can use different encodings.

    IMMValue = BinCode[CodePos32];

    //Loop and Move the Decoder to the next byte Code position to the number of bytes to reads.

    for (var i = 0, v = ""; i < n; i++, NextByte())
    {
        v = BinCode[CodePos32].toString(16); //convert the current Bin Code array Position byte to a ASCII hex string

        if (v.length < 2) //if the Hex byte is one digit which is half a byte then
        {
            v = "0" + v; //pad the read byte value to a byte if it's less than two hex digits
        }

        imm = v + imm; //put each byte into the back of the string basically building the string backwards in memory
    }

    //The above loop will correctly read the value based on the immediate operands size and store it into the variable "imm".

    //If the IMM type is used with an register operand on the upper four bit's then the IMM byte does not use the upper 4 bit's.

    if(type == 1) { imm = "0" + imm.substring(1, imm.length); }

    //If the IMM type is for relative address, or Singed Integer set up the two 32 bit integers for 64 simulation.

    if (type == 2 | type == 3)
    {
        //convert the immediate into two hex strings that are 32 in size because JavaScript only works with 32 bit integers

        var HexStr32 = imm.slice(-8);
        var HexStr64 = imm.substring(0, imm.length - 8);

        //convert both sections into A 32 bit integer

        var Imm32Int32 = parseInt(HexStr32, 16);
        var Imm64Int32 = parseInt(HexStr64, 16);

        //find the number of bytes to use from 32 bit number section.
        //the minim value is 4 bytes because JavaScript maxes out at int 32, But if the Relative Immediate is smaller it will use the smaller value as number of bytes.

        var B32 = Math.min(4, n); //32 bit is usable by sizes 8, 16, 32

        //note B64 is not necessary because IMM goes 32 then 64 in size so aether the 64 sections is used, or not used.

        if (type == 2) //if it is a Relative address type
        {

            //the math equation bellow multiples the IMM size by 8 to find how many binary bits are needed to be calculated for the number of bytes
            //then 2 to the power of size times 8 calculates the max value for each binary digit to byte size subtracting by one starts at max value

            var bits32 = Math.pow(2, B32 * 8) - 1; //The first 32 bits

            //Add the first 32 bits normally if the tow numbers have to carry to the 64 section of the 32 bit integer

            var Carrie64 = 0x00000000;

            if ((Imm32Int32 + Pos32) > 0xFFFFFFFF)
            {
                Carrie64 = 0x00000003;
            }

            //Find the bits higher up if any as the none effected bits after the relative add

            var RIMM32 = (Pos32 - (Pos32 & bits32)) & 0xFFFFFFFF; //Because IMM goes 8, 16, 32 RIMM has to be calculated for unused sections higher in size.

            //start adding up the 32, and 64 section to number of bits allowed from 32 till 64

            var IMM32 = (Pos32 + Imm32Int32) & bits32;
            var IMM64 = (Pos64 + Imm64Int32 + Carrie64) & 0xFFFFFFFF;

            //add back the rest of the remaining value that has not been effected by bits size because of Relative IMM size

            IMM32 += RIMM32;
            if ( S != 3 ) { IMM64 += Pos64; } //IMM goes from 32 to 64 so the 64 section is used, or aether not used.

            //the above would be perfect for relative Position sizes 8,16,32,64 if JavaScript did not max out at a 32 bit singed integer
            //fix negative sing error by inverting the value with 32 bit add to max 32 plus one for correction
            //reason JavaScript uses 32 bit integers by default this is one of the ways to correct values that go to the
            //32 bit known as sing bit

            if (IMM32 < 0) { IMM32 = (0xFFFFFFFF + IMM32) + 1; }
            if (IMM64 < 0) { IMM64 = (0xFFFFFFFF + IMM64) + 1; }

            //If the OvOperands prefix is used 66 hex which sets SizeAttrSelect 0 then IMM64 is zeroed out and IMM32 is fixed to & 0x0000FFFF basically first 16 calculated bits

            if (SizeAttrSelect == 0) { IMM64 = 0x00000000; IMM32 = IMM32 & 0x0000FFFF; }

            //convert to hex, and pad it to 0 for correct size for both 32 bit parts of the 64 address.

            for (IMM32 = IMM32.toString(16) ; IMM32.length < 8; IMM32 = "0" + IMM32);
            for (IMM64 = IMM64.toString(16) ; IMM64.length < 8; IMM64 = "0" + IMM64);

            //Put the 64 bit address together.

            imm = IMM64 + IMM32;
        }

        else if (type == 3) //if it is singed int Displacement Calculate and simulate Integer Center Points for Immediate Sizes 8,16,32.
        {
            var Sing = false; //the sing value for if the Displacement is added or subtracted from center.

            //Simulate negative positive integers using values bigger than 32.

            var Half32 = Math.pow(2, (B32 * 8) - 1); //calculate the 32 bit value center for integers smaller than 32 or are 32.

            if (Imm32Int32 >= Half32) //when the value is higher than the center it is negative.
            {
                Sing = true; //set sing true for negative.
                HexStr32 = (Half32 - (-(Half32 - Imm32Int32))).toString(16); //simulate the integer center point give the value as a positive number sizes 32 and bellow
            }

            for (var HTB = B32 * 2; HexStr32.length < HTB; HexStr32 = "0" + HexStr32); //pad to the number of bytes for the integer that is 32 or bellow

            imm = HexStr32; //set IMM the new center for this hex string

            if (Sing) { imm = "-" + imm; } else { imm = "+" + imm; } //set IMM to add or subtract for the integer sing

        }

    }

    //PAD the Immediate to it's actual size some Immediate's do not match the size the Destination operand is even by there size attributes.
    //if PAD is different than pad the IMM to correct size using the last bit as the sing.

    if(PAD != S)
    {

        //Use the same calculation that S used to find number of bytes except multiply by 2 because 2 hex digits is one byte

        PAD = Math.pow( 2, PAD ) * 2;

        //convert last binary bit to a boolean

        var sing = (parseInt(imm.substring(0, 1), 16) & 8) >> 3;

        //pad the Immediate to the extend size using FF hex which FF is 11111111 in binary if the sing bit is logic one otherwise 00 which is 00000000 binary

        var pd = "00"; //by default pads using 00000000 binary

        if (sing) //if the last bit is active then
        {
            pd = "FF"; //pad using 11111111 binary
        }

        //start padding.

        for (; imm.length < PAD; imm = pd + imm);

    }

    //return the immediate result

    return (imm.toUpperCase());

};

/*-------------------------------------------------------------------------------------------------------------------------
Decode registers by Size attributes, or a select register index.
-------------------------------------------------------------------------------------------------------------------------*/

function DecodeRegValue(RValue, BySize, Setting) {

  //If By size is true Use the Setting with the GetOperandSize

  if (BySize)
  {
    Setting = GetOperandSize(Setting); //get decoded size value.
  }

  //check if Register is a XMM register which allows SIMD vector extension.

  if(Setting >= 4 & Setting <= 7){ SSE = true; }

  //if 8 bit Registers

  if (Setting == 0)
  {
    //if any Rex Prefix

    if (RexActive) { return (REG[0][1][ RegExtend | RValue ]); }

    //else use high low order

    else { return (REG[0][0][ RegExtend | RValue ]); }
  }

  //No other Separations.

  if (REG[Setting].length <= RegExtend) { RegExtend = REG[Setting].length - 8; } //Limit Extend Value to max amount of register indexes

  //Return the Register.

  return (REG[Setting][ RegExtend | RValue ]);

};

/*-------------------------------------------------------------------------------------------------------------------------
Decode the ModR/M pointer, and Optional SIB if used.
Note if by size attributes is false the lower four bits is the selected Memory pointer,
and the higher four bits is the selected register.
-------------------------------------------------------------------------------------------------------------------------*/

function Decode_ModRM_SIB_Address(ModRM, BySize, Setting){

  var out = ""; //the variable out is what stores the decoded address pointer, or Register if Register mode.

  //-------------------------------------------------------------------------------------------------------------------------
  //If the ModR/M is not in register mode decode it as an Effective address.
  //-------------------------------------------------------------------------------------------------------------------------

  if(ModRM[0] != 3)
  {

    //-------------------------------------------------------------------------------------------------------------------------
    //The Selected Size is setting unless BySize attribute is true.
    //-------------------------------------------------------------------------------------------------------------------------

    if (BySize)
    {
      Setting = (GetOperandSize(Setting) << 1) | FarPointer;
    }

    //-------------------------------------------------------------------------------------------------------------------------
    //If By size attributes is false the selected Memory pointer is the first four bits of the size setting for all pointer indexes 0 to 15.
    //Also if By size attribute is also true the selected by size index can not exceed 15 anyways which is the max combination the first four bits.
    //-------------------------------------------------------------------------------------------------------------------------

    Setting = Setting & 0x0F;

    //check if Register is a XMM register which allows SIMD vector extension.

    if( ( Setting >= 8 & Setting <= 14 ) & ( Setting % 2 <= 0 ) ){ SSE = true; }

    //-------------------------------------------------------------------------------------------------------------------------
    //Get the pointer size by Size setting.
    //-------------------------------------------------------------------------------------------------------------------------

    out = PTR[Setting];

    //Add the Segment override left address bracket if any segment override was used otherwise the SegOverride string should be just a normal left bracket.

    out += SegOverride;

    //-------------------------------------------------------------------------------------------------------------------------
    //calculate the actual address size according to the Address override and the CPU bit mode.
    //-------------------------------------------------------------------------------------------------------------------------
    //AddressSize 1 is 16, AddressSize 2 is 32, AddressSize 3 is 64.
    //The Bit mode is the address size except AddressOverride reacts differently in different bit modes.
    //In 16 bit AddressOverride switches to the 32 bit ModR/M effective address system.
    //In both 32/64 the Address size goes down by one is size.
    //-------------------------------------------------------------------------------------------------------------------------

    var AddressSize = BitMode + 1;

    if (AddressOverride)
    {
      AddressSize = AddressSize - 1;

      //the only time the address size is 0 is if the BitMode is 16 bit's and is subtracted by one resulting in 0.

      if(AddressSize == 0)
      {
        AddressSize = 2; //set the address size to 32 bit from the 16 bit address mode.
      }
    }

    /*-------------------------------------------------------------------------------------------------------------------------
    The displacement size Displacement*N calculation.
    ---------------------------------------------------------------------------------------------------------------------------
    In 16/32/64 the mode setting 1 will always add a Displacement of 8 to the address.
    In 16 the Mode setting 2 adds a displacement of 16 to the address.
    In 32/64 the Mode Setting 2 for the effective address adds an displacement of 32 to the effective address.
    -------------------------------------------------------------------------------------------------------------------------*/

    var Disp = ModRM[0] - 1; //Let disp relate size to mode value of the ModR/M.

    //if 32 bit and above, and if Mode is 2 then disp size is disp32.

    if(AddressSize >= 2 & ModRM[0] == 2)
    {
      Disp += 1; //Only one more higher in size is 32.
    }

    /*-------------------------------------------------------------------------------------------------------------------------
    End of Displacement*N calculation.
    -------------------------------------------------------------------------------------------------------------------------*/

    /*-------------------------------------------------------------------------------------------------------------------------
    Normally the displacement type is an relative Immediate that is added ("+"),
    or subtracted ("-") from the center point to the selected base register,
    and the size depends on mode settings 1, and 2, and also Address bit mode (Displacement*N calculation).
    Because the normal ModR/M format was limited to Relative addresses, and unfixed locations,
    so some modes, and registers combinations where used for different Immediate displacements.
    -------------------------------------------------------------------------------------------------------------------------*/

    var DispType = 3; //by default the displacement size is added to the selected base register, or Index register if SIB byte combination is used.

    //-------------------------------------------16 Bit ModR/M address decode logic-------------------------------------------

    if( AddressSize == 1 )
    {

      //if ModR/M mode bits 0, and Base Register value is 6 then disp16 with DispType mode 0.

      if(AddressSize == 1 & ModRM[0] == 0 & ModRM[2] == 6)
      {
        Disp = 1;
        DispType = 0;
      }

      //BX , BP switch based on bit 2 of the Register value

      if( ModRM[2] < 4 ){ out += REG[ AddressSize ][ 3 + ( ModRM[2] & 2 ) ] + "+"; }

      //The first bit switches between Destination index, and source index

      if( ModRM[2] < 6 ){ out += REG[ AddressSize ][ 6 + ( ModRM[2] & 1 ) ]; }

      //[BP], and [BX] as long as Mode is not 0, and Register is not 6 which sets DispType 0.

      else if ( DispType != 0 ) { out += REG[ AddressSize ][ 17 - ( ModRM[2] << 1 ) ]; }

    } //End of 16 bit ModR/M decode logic.

    //-------------------------------------------Else 32/64 ModR/M-------------------------------------------

    else
    {

      //if Mode is 0 and Base Register value is 5 then it uses an Relative (RIP) disp32.

      if(ModRM[0] == 0 & ModRM[2] == 5)
      {
        Disp = 3;
        DispType = 2;
      }

      //check if Base Register is 4 which goes into the SIB address system

      if(ModRM[2] == 4)
      {

        //Decode the SIB byte.

        var SIB = Decode_ModRM_SIB_Value();

        //Calculate the Index register with it's Extended value because the index register will only cancel out if 4 in value.

        var IndexReg = IndexExtend | SIB[1];

        //check if the base register is 5 in value in the SIB without it's added extended value, and that the ModR/M Mode is 0 this activates Disp32

        if (ModRM[0] == 0 & SIB[2] == 5)
        {
          Disp = 2; //Set Disp32

          //check if the Index register is canceled out as well

          if (IndexReg == 4) //if the Index is canceled out then
          {
            DispType = 0; //a regular IMM32 is used as the address.

            //*if the Address size is 64 then the 32 bit Immediate must pad to the full 64 bit address.

            if(AddressSize == 3) { Disp = 50; }
          }
        }

        //Else Base register is not 5, and the Mode is not 0 then decode the base register normally.

        else
        {

          out += REG[ AddressSize ][ BaseExtend | SIB[2] ];

          //If the Index Register is not Canceled out (Note this is only reachable if base register was decoded and not canceled out)

          if (IndexReg != 4)
          {
            out = out + "+"; //Then add the Plus in front of the Base register to add the index register
          }
        }

        //if Index Register is not Canceled out at the end then decode the Index with the possibility of the base register.

        if (IndexReg != 4)
        {

          out += REG[ AddressSize ][ IndexExtend | IndexReg ];

          //add what the scale bits decode to the Index register by the value of the scale bits which select the name from the scale array.

          out = out + scale[SIB[0]];
        }

      } //END OF THE SIB BYTE ADDRESS DECODE.

      //else Base register is not 4 and does not go into the SIB ADDRESS
      //Decode the Base register regularly plus it's Extended value if relative (RIP) disp32 is not used.

      else if(DispType != 2)
      {
        out += REG[ AddressSize ][ BaseExtend | ModRM[2] ];
      }
    }

    //Finally the Immediate displacement is put into the Address last.

    if(Disp >= 0 ) { out += DecodeImmediate(DispType, false, Disp); }

    //If Broadcast round is active from an EVEX extension instruction

    if(BRound)
    {

      //If a vector size of B32 is given back put the Memory vector size as 1to16.

      if(Setting == 4 & BySize)
      {
        out += "]{1to16}";
      }

      //Else If a vector size of B64 is given back put the Memory vector size as 1to8.

      else if(Setting == 6 & BySize)
      {
        out += "]{1to8}";
      }

      //Else Invalid Broadcast pointer size.

      else{ out = "]{Error}"; }

    } //END of broadcast Round logic.

    //else the pointer size is not effected by Broadcast round then add right bracket to the ModR/M address normally.

    else
    {
      out += "]";
    }

  } //End of Memory address Modes 00, 01, 10 decode.

  //-----------------------------else the ModR/M mode bits are 11 register Mode-----------------------------

  else
  {
    //If By size attributes is false the upper four bits is used for the selected Register 0 to 15.

    if(!BySize)
    {
      Setting = Setting >> 8;
    }

    //Decode the select register though the register decode function.

    out = DecodeRegValue(BaseExtend | ModRM[2], BySize, Setting);
  }

  //return what the "Register mode" is, or "Memory address"

  return (out);

}; //End of ModR/M address Base Register Effective Address decode, and mode bit's decode.

/*-------------------------------------------------------------------------------------------------------------------------
Decode Prefix Mnemonic codes. Note Some disable depending on the bit mode of the CPU.
If a prefix is disabled and not read by this function it allows it to be decoded as an instruction in the Decode Opcode function.
Some instructions can only be used in 32 bit mode such as instructions LDS and LES.
LDS and LES where changed to Vector extension attribute adjustments to SSE instructions in 64 bit.
At the end of this function "Opcode" should not hold any prefix code, so then Opcode contains an operation code.
-------------------------------------------------------------------------------------------------------------------------*/

function DecodePrefixAdjustments(){

  //-------------------------------------------------------------------------------------------------------------------------
  Opcode |= BinCode[CodePos32]; //Add 8 bit opcode while bits 9, and 10 are used for opcode map.
  NextByte(); //Move to the next byte.
  //-------------------------------------------------------------------------------------------------------------------------

  //if 0F hex start at 256 for Opcode.

  if(Opcode == 0x0F)
  {
    Opcode = 0x100; //By starting at 0x100 with binary bit 9 set one then adding the 8 bit opcode then Opcode goes 256 to 511.
    return(DecodePrefixAdjustments()); //restart function decode more prefix settings that can effect the decode instruction.
  }

  //if 38 hex while using two byte opcode.

  else if(Opcode == 0x138)
  {
    Opcode = 0x200; //By starting at 0x200 with binary bit 10 set one then adding the 8 bit opcode thn Opcode goes 512 to 767.
    return(DecodePrefixAdjustments()); //restart function decode more prefix settings that can effect the decode instruction.
  }

  //if 3A hex while using two byte opcode go three byte opcodes.

  else if(Opcode == 0x13A)
  {
    Opcode = 0x300; //By starting at 0x300 hex and adding the 8 bit opcode then Opcode goes 768 to 1023.
    return(DecodePrefixAdjustments()); //restart function decode more prefix settings that can effect the decode instruction.
  }

  //Prefix codes that are only active well in 64 bit mode.

  if( BitMode == 2 )
  {
    //The Rex prefix bit settings decoding

    if( Opcode >= 0x40 & Opcode <= 0x4F)
    {
      BaseExtend = (Opcode & 0x01) << 3; //Base Register extend setting.
      IndexExtend = ( ( Opcode & 0x02 ) ) << 2; //Index Register extend setting.
      RegExtend = ( ( Opcode & 0x04 ) ) << 1; //Register Extend Setting.
      SizeAttrSelect = ( ( Opcode & 0x08 ) >> 2 ); //The width Bit open all 64 bits.
      WidthBit = SizeAttrSelect >> 1; //Set The Width Bit setting if active.
      return(DecodePrefixAdjustments()); //restart function decode more prefix settings that can effect the decode instruction.
    }

    //The VEX2 Operation code Extension to SSE settings decoding.

    if( Opcode == 0xC5 )
    {
      //-------------------------------------------------------------------------------------------------------------------------
      Opcode = BinCode[CodePos32]; //read VEX2 byte settings.
      NextByte(); //Move to the next byte.
      //-------------------------------------------------------------------------------------------------------------------------

      //some bits are inverted, so uninvert them arithmetically.

      Opcode = ( 0xF8 - ( Opcode & 0xF8 ) ) | ( Opcode & 0x07 );

      //Decode bit settings.

      RegExtend = ( Opcode & 0x80 ) >> 4; //Register Extend.
      VectorRegister = ( Opcode & 0x78 ) >> 3; //The added in Vector register to SSE.
      SizeAttrSelect = ( Opcode & 0x04 ) >> 2; //The L bit for 256 vector size.
      SIMD = Opcode & 0x03; //The SIMD mode.

      //Autmatically uses the two byte opcode map starts at 256 goes to 511.

      Opcode = 0x100;

      //-------------------------------------------------------------------------------------------------------------------------
      Opcode |= BinCode[CodePos32]; //read the opcode.
      NextByte(); //Move to the next byte.
      //-------------------------------------------------------------------------------------------------------------------------

      //Stop decoding prefixes send back code for VEX.

      return(1);
    }

    //The VEX3 prefix settings decoding.

    if( Opcode == 0xC4 )
    {
      //-------------------------------------------------------------------------------------------------------------------------
      Opcode = BinCode[CodePos32]; //read VEX3 byte settings.
      NextByte(); //Move to the next byte.
      //-------------------------------------------------------------------------------------------------------------------------
      Opcode |= ( BinCode[CodePos32] << 8 ); //Read next VEX3 byte settings.
      NextByte(); //Move to the next byte.
      //-------------------------------------------------------------------------------------------------------------------------

      //Some bits are inverted, so uninvert them arithmetically.

      Opcode = ( 0x78E0 - ( Opcode & 0x78E0 ) ) | ( Opcode & 0x871F );

      //Decode bit settings.

      RegExtend = ( Opcode & 0x0080 ) >> 4; //Extend Register Setting.
      IndexExtend = ( Opcode & 0x0040 ) >> 3; //Extend Index register setting.
      BaseExtend = ( Opcode & 0x0020 ) >> 2; //Extend base Register setting.
      WidthBit = ( Opcode & 0x8000 ) >> 15; //The width bit works as a separator.
      VectorRegister = ( Opcode & 0x7800 ) >> 11; //The added in Vector register to SSE.
      SizeAttrSelect = ( Opcode & 0x0400 ) >> 10; //Vector length for 256 setting.
      SIMD = ( Opcode & 0x0300 ) >> 8; //The SIMD mode.

      Opcode = ( Opcode & 0x001F ) << 8; //Change Operation code map.

      //-------------------------------------------------------------------------------------------------------------------------
      Opcode |= BinCode[CodePos32]; //read the 8 bit opcode put them in the lower 8 bits away from opcode map bit's.
      NextByte(); //Move to the next byte.
      //-------------------------------------------------------------------------------------------------------------------------

      //Stop decoding prefixes send back code for VEX.

      return(1);
    }

    //The EVEX prefix settings decoding.

    if( Opcode == 0x62 )
    {
      //-------------------------------------------------------------------------------------------------------------------------
      Opcode = BinCode[CodePos32]; //read EVEX byte settings.
      NextByte(); //Move to the next byte.
      //-------------------------------------------------------------------------------------------------------------------------
      Opcode |= ( BinCode[CodePos32] << 8 ); //read next EVEX byte settings.
      NextByte(); //Move to the next byte.
      //-------------------------------------------------------------------------------------------------------------------------
      Opcode |= ( BinCode[CodePos32] << 16 ); //read next EVEX byte settings.
      NextByte(); //Move to the next byte.
      //-------------------------------------------------------------------------------------------------------------------------

      //Some bits are inverted, so uninvert them arithmetically.

      Opcode = ( 0x087CF0 - ( Opcode & 0x087CF0 ) ) | ( Opcode & 0xF7870F );

      //Check if Reserved bits are 0 if they are not 0 the EVEX instruction is invalid.

      if( ( Opcode & 0x00040C ) > 0 ) { InvalidOp = true; }

      //Decode bit settings.

      RegExtend = ( ( Opcode & 0x80 ) >> 4 ) | ( Opcode & 0x10 ); //The Double R'R bit decode for Register Extension 0 to 32.
      BaseExtend = ( Opcode & 0x60 ) >> 2; //The X bit, and B Bit base register extend combination 0 to 32.
      IndexExtend = ( Opcode & 0x40 ) >> 3; //The X extends the SIB Index by 8.
      WidthBit = ( Opcode & 0x8000 ) >> 15; //The width bit separator for VEX, EVEX.
      VectorRegister = ( Opcode & 0x7800 ) >> 11; //The Added in Vector Register for SSE under VEX, EVEX.
      SIMD = ( Opcode & 0x0300 ) >> 8; //decode the SIMD mode setting.
      ZeroMerg = ( Opcode & 0x800000 ) >> 23; //Zero Merge to destination control.
      SizeAttrSelect = ( Opcode & 0x600000 ) >> 21; //The EVEX.L'L Size combination.
      BRound = (Opcode & 0x100000 ) >> 20; //Broadcast Round Memory address system.
      VectorRegister |= ( Opcode & 0x080000 ) >> 15; //The EVEX.V' vector extension adds 15 to EVEX.V3V2V1V0.
      MaskRegister = ( Opcode & 0x070000 ) >> 16; //Mask to destination.

      Opcode = ( Opcode & 0x03 ) << 8; //Change Operation code map.

      //-------------------------------------------------------------------------------------------------------------------------
      Opcode |= BinCode[CodePos32]; //read the 8 bit opcode put them in the lower 8 bits away from opcode extend bit's.
      NextByte(); //Move to the next byte.
      //-------------------------------------------------------------------------------------------------------------------------

      //Stop decoding prefixes send back code for EVEX.

      return(2);
    }

  }

  //Segment overrides

  if (Opcode == 0x2E | Opcode == 0x36 | Opcode == 0x3E | Opcode == 0x64 | Opcode == 0x65)
  {
    SegOverride = Mnemonics[ Opcode ]; //Set the Left Bracket for the ModR/M memory address.
    return(DecodePrefixAdjustments()); //restart function decode more prefix settings that can effect the decode instruction.
  }

  //Operand override Prefix

  if(Opcode == 0x66)
  {
    SIMD = 1; //sets SIMD mode 1 in case of SSE instruction opcode.
    SizeAttrSelect = 0; //Adjust the size attribute setting for the size adjustment to the next instruction.
    return(DecodePrefixAdjustments());  //restart function decode more prefix settings that can effect the decode instruction.
  }

  //Ram address size override.

  if(Opcode == 0x67)
  {
    AddressOverride = true; //Set the setting active for the ModR/M address size.
    return(DecodePrefixAdjustments()); //restart function decode more prefix settings that can effect the decode instruction.
  }

  //if repeat Prefixes F2 hex REP,or F3 hex RENP

  if (Opcode == 0xF2 | Opcode == 0xF3)
  {
    SIMD = Opcode & 0x03 ; //F2, and F3 change the SIMD mode during SSE instructions.
    PrefixG1 = Mnemonics[ Opcode ]; //set the Prefix string
    HLEFlipG1G2 = true; //set Filp HLE in case this is the last prefix read, and LOCK was set in string G2 first for HLE.
    return(DecodePrefixAdjustments()); //restart function decode more prefix settings that can effect the decode instruction.
  }

  //if the lock prefix note the lock prefix is separate

  if (Opcode == 0xF0)
  {
    PrefixG2 = Mnemonics[ Opcode ]; //set the Prefix string
    HLEFlipG1G2 = false; //set Flip HLE false in case this is the last prefix read, and REP, or REPNE was set in string G2 first for HLE.
    return(DecodePrefixAdjustments()); //restart function decode more prefix settings that can effect the decode instruction.
  }

  return(0); //regular opcode no extension active like VEX, or EVEX.

};

/*-------------------------------------------------------------------------------------------------------------------------
The Decode opcode function gives back the operation name, and what it uses for input.
The input types are for example which registers it uses with the ModR/M, or which Immediate type is used.
The input types are stored into an operand string. This function gives back the instruction name, And what the operands use.
---------------------------------------------------------------------------------------------------------------------------
This function is designed to be used after the Decode prefix adjustments function because the Opcode should contain an real instruction code.
This is because the Decode prefix adjustments function will only end if the Opcode value is not a prefix adjustment code to the ModR/M etc.
-------------------------------------------------------------------------------------------------------------------------*/

function DecodeOpcode( Extension ){

  //get the Operation name by the operations opcode.

  var Name = Mnemonics[Opcode];

  //get the Operands for this opcode it follows the same array structure as Mnemonics array

  var Type = Operands[Opcode];

  //Some Opcodes use the next byte automatically for extended opcode selection. Or current SIMD mode.

  var ModRMByte = BinCode[CodePos32]; //Read the byte but do not move to the next byte.

  //If the current Mnemonic is an array two in size then Register Mode, and memory mode are separate from each other.

  if(Name instanceof Array && Name.length == 2)
  {

     //if Register mode

     if( ( ModRMByte & 0xC0 ) == 0xC0 )
     {
       Name = Name[1];
       Type = Type[1];
     }

     //else Address mode

     else
     {
       Name = Name[0];
       Type = Type[0];
     }
  }

  //if the current Mnemonic is an array 8 in length

  if(Name instanceof Array && Name.length == 8)
  {

    //Group opcode.

    Name = Name[ ( ModRMByte & 0x38 ) >> 3 ];
    Type = Type[ ( ModRMByte & 0x38 ) >> 3 ];

    //if The select Group opcode is another array 8 in size it is a static opcode selection

    if(Name instanceof Array && Name.length == 8)
    {
      Name = Name[ ( ModRMByte & 0x07 ) ];
      Type = Type[ ( ModRMByte & 0x07 ) ];
    }

  }

  //if the Mnemonic is an array 3 in size the instruction name goes by size.

  if(Name instanceof Array && Name.length == 3)
  {
    if (Name[SizeAttrSelect] != "")
    {
      Name = Name[SizeAttrSelect]; //set it to the Mnemonic
      Type = Type[SizeAttrSelect]; //Operand array always matches the Mnemonic structure
    }

    //else no size prefix use default size Mnemonic name

    else
    {
      Name = Name[1]; //set it to the Mid default Mnemonic
      Type = Type[1]; //Operand array always matches the Mnemonic structure
    }
  }

  //if the current Mnemonic is an array 4 in size it is an SSE, or MMX instruction

  if(Name instanceof Array && Name.length == 4)
  {

    //Reset the prefix string G1 because prefix codes F2, and F3 are used with SSE which forum the repeat prefix.
    //Some SSE instructions can use the REP, RENP prefix thus the SSE mode uses Packed Single format.

    if(Name[SIMD] != "")
    {
      PrefixG1 = "";
      Name = Name[SIMD];
      Type = Type[SIMD];
    }
    else{Name = Name[0];Type = Type[0];}

  }

  //If Extension is not 0 then add the vector extend "V" to the instruction.
  //During the decoding of the operands the instruction can be returned as invalid if it is an Arithmetic, or MM, ST instruction.

  if(Extension > 0){ Name = "V" + Name; }

  //return the instruction and encoding type.

  return( [ Name, Type ] );

};

/*-------------------------------------------------------------------------------------------------------------------------
Read each operand in the Operand String then set the correct operand in the decoder array.
And also OpNum is the order the operands are read in the operand string this number is set the the operand in the decoder array.
Each set operand will be decoded by the function DecodeOperands(). The OpNum is the order the decoded operands will be
positioned. The order the operands display is different than the order they decode in sequence.
-------------------------------------------------------------------------------------------------------------------------*/

function DecodeOperandString( OperandString, Extension ){

  //Variables that are used for decoding one operands across the operand string.

  var OperandValue = 0, Code = 0, BySize = 0, Setting = 0;

  //It does not matter which order the explicit operands decode as they do not require reading another byte.
  //They start at 7 and are set in order, but the order they are displayed is the order they are read in the operand string because of OpNum.

  var ExplicitOp = 7;

  //Each operand is 4 hex digits, and OpNum is added by one for each operand that is read per Iteration.

  for(var i = 0, OpNum = 0; i < OperandString.length; i+=4, OpNum++ ) //Iterate though operand string.
  {
    OperandValue = parseInt( OperandString.substring(i, (i + 4) ) ); //Convert the four hex digits to a 16 bit number value.

    Code = ( OperandValue & 0xFE00 ) >> 9; //Get the operand Code.
    BySize = ( OperandValue & 0x0100 ) >> 8; //Get it's by size attributes setting for if Setting is used as size attributes.
    Setting = ( OperandValue & 0x00FF ); //Get the 8 bit Size setting.

    //if it is a opcode Reg Encoding then first element along the decoder is set.

    if( Code == 1 )
    {
      X86Decoder[0].set(0, BySize, Setting, OpNUm );
    }

    //if it is a ModR/M, or Far pointer ModR/M, or Moffs address.

    else if( Code >= 2 & Code <= 4 )
    {
      X86Decoder[1].set( ( Code - 2 ), BySize, Setting, OpNUm );
    }

    //The ModR/M Reg bit's

    else if( Code == 5 )
    {
      X86Decoder[2].set(0, BySize, Setting, OpNUm );
    }

    //Immediate input one.

    else if( Code >= 6 & Code <= 8 )
    {
      X86Decoder[3].set( ( Code - 6 ), BySize, Setting, OpNUm );
    }

    //Immediate Input two.

    else if( Code >= 9 & Code <= 11 )
    {
      X86Decoder[4].set( ( Code - 9 ), BySize, Setting, OpNUm );
    }

    //Vector register, only set the vector register if Vector extension is active.

    else if( Code == 12 & Extension > 0 )
    {
      X86Decoder[5].set(0, BySize, Setting, OpNUm );
    }

    //The upper four bits of the Immediate is used as an register.

    else if( Code == 13 )
    {
      X86Decoder[6].set(0, BySize, Setting, OpNUm );
    }

    //Else any other encoding type higher than 13 is an explicit operand selection.
    //And also there can only be an max of four explicit operands.

    else if( Code >= 14 & ExplicitOp < 10)
    {
      X86Decoder[ExplicitOp].set( ( Code - 14 ), BySize, Setting, OpNUm );
      ExplicitOp++; //move to the next Explicit operand.
    }

  }

}

/*-------------------------------------------------------------------------------------------------------------------------
Decode each of the operands along the X86Decoder and detectives them.
-------------------------------------------------------------------------------------------------------------------------*/

function DecodeOperands( FOperands ){

}
